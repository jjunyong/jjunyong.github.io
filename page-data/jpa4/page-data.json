{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/jpa4/",
    "result": {"data":{"cur":{"id":"d55f696e-f426-568d-a0cf-2ec92a0ff11c","html":"<p>JPA의 내부동작, 즉 영속성 컨텍스트의 정의, 장점, 라이프사이클 등에 대해서\b 이전 글을 통해 알아 봤다면,\n이제 Entity 매핑을 실제로 어떻게 하는 지를 알아보자.</p>\n<h2 id=\"1-객체와-테이블-맵핑--entity-table-\" style=\"position:relative;\"><a href=\"#1-%EA%B0%9D%EC%B2%B4%EC%99%80-%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%A7%B5%ED%95%91--entity-table-\" aria-label=\"1 객체와 테이블 맵핑  entity table  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 객체와 테이블 맵핑 ( @Entity, @Table )</h2>\n<p>@Entity가 붙은 클래스는 JPA가 관리하게 된다.</p>\n<ul>\n<li>\n<p>Entity 작성 시 주의사항</p>\n<ul>\n<li>기본 생성자는 필수이다.</li>\n<li>final, enum, interface, inner 클래스 사용 X</li>\n<li>저장할 필드에 final 사용 X</li>\n</ul>\n</li>\n<li>\n<p>@Table은 엔티티와 맵핑할 테이블 지정 가능</p>\n</li>\n</ul>\n<h2 id=\"2-db-스키마-자동-생성\" style=\"position:relative;\"><a href=\"#2-db-%EC%8A%A4%ED%82%A4%EB%A7%88-%EC%9E%90%EB%8F%99-%EC%83%9D%EC%84%B1\" aria-label=\"2 db 스키마 자동 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. DB 스키마 자동 생성</h2>\n<ul>\n<li>\n<p>JPA에서는 DDL을 앱 실행 시점에 자동 생성해준다. ( 운영 환경에서는 사용하면 안됨 )</p>\n<p>: JPA가 테이블 중심이 아닌 객체 중심임을 보여준다.</p>\n</li>\n<li>\n<p>persistence.xml에서 아래와 같이 옵션이 설정되어 있어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>hibernate.hbm2ddl.auto<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>create<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n</li>\n</ul>\n<p>여기서 value값에 옵션을 지정해주는데 옵션의 종류는 아래와 같다.</p>\n<ul>\n<li>create : 기존테이블 삭제 후 다시 생성(DROP + CREATE)</li>\n<li>create-drop : create과 같으나 종료시전에 테이블 DROP</li>\n<li>update : 변경분만 반영</li>\n<li>validate : 엔티티와 테이블이 정상 매핑되었는지만 확인</li>\n<li>none : 사용하지 않음을 의미</li>\n</ul>\n<p>옵션에 따라 어플리케이션 실행 시 위와 같이 DDL이 생성되기 때문에 환경에 따라 철저히 옵션을 구분해서 아래와 같이 사용해야 한다.</p>\n<p>​</p>\n<ul>\n<li>운영장비:  create, create-drop, update사용하면 안되고 validate  / none 사용</li>\n<li>개발 초기:  create / update</li>\n<li>어느정도 개발이 진행되었다면 : update / validate</li>\n</ul>\n<h2 id=\"3-필드와-컬럼-맵핑--column\" style=\"position:relative;\"><a href=\"#3-%ED%95%84%EB%93%9C%EC%99%80-%EC%BB%AC%EB%9F%BC-%EB%A7%B5%ED%95%91--column\" aria-label=\"3 필드와 컬럼 맵핑  column permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 필드와 컬럼 맵핑 (@ Column)</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Id</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> memberName<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> age<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Enumerated</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">EnumType</span><span class=\"token punctuation\">.</span>STRING<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">RoleType</span> roleType<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//varchar로 생성됨. 정해진 status값 같은 데 쓰면 됨</span>\n    <span class=\"token annotation punctuation\">@Lob</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> description<span class=\"token punctuation\">;</span> <span class=\"token comment\">//문자면 CLOB으로, 나머지는 BLOB으로 맵핑 됨.  </span>\n    <span class=\"token annotation punctuation\">@Transient</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> temp<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// DDL 생성하지 않고 애플리케이션 내에서만 사용하게 됨 </span></code></pre></div>\n<h3 id=\"1-column\" style=\"position:relative;\"><a href=\"#1-column\" aria-label=\"1 column permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) @Column</h3>\n<ul>\n<li>nullable : false,true ( DDL에서 not null constraint 걸어 주고 validation도 지원 )</li>\n<li>length : String에서 길이 제한</li>\n<li>precision : BigDecimal처럼 엄청 큰 숫자를 사용하는 컬럼의 소수점을 지정해줄 때 사용</li>\n</ul>\n<h3 id=\"2-enumtype--쓸-때-주의-사항\" style=\"position:relative;\"><a href=\"#2-enumtype--%EC%93%B8-%EB%95%8C-%EC%A3%BC%EC%9D%98-%EC%82%AC%ED%95%AD\" aria-label=\"2 enumtype  쓸 때 주의 사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) EnumType  쓸 때 주의 사항</h3>\n<p>​기본이 ORDINAL이고 STRING으로 지정 가능한데 반드시 STRING으로 써야 한다.</p>\n<p>ORDINAL은 enum의 순서 정보를, STRING은 enum의 이름을 DB에 저장하게 되는데,</p>\n<p>ORDINAL을 쓰면 안되는 이유는 enum에서 값이 추가 됐을 경우에 DB에 기존에 있던 데이터와 앱 상에서 업데이트 된 enum의 순서에 대한 정보가 꼬이게 되어 버그 발생할 수 있기 때문이다.</p>\n<h3 id=\"3-기본-키-맵핑-전략\" style=\"position:relative;\"><a href=\"#3-%EA%B8%B0%EB%B3%B8-%ED%82%A4-%EB%A7%B5%ED%95%91-%EC%A0%84%EB%9E%B5\" aria-label=\"3 기본 키 맵핑 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) 기본 키 맵핑 전략</h3>\n<p>@Id</p>\n<p>@GeneratedValue(strategy = GenerationType.{IDENTITY, TABLE, SEQUENCE, AUTO}</p>\n<p>-> id에 대한 생성 전략은 크게 identity, table, sequence 3가지 이며 auto로 설정할 경우 properties파일에서 설정한 jpa의 dialect에 따라서 알아서 설정을 해준다. mysql은 IDENTITY, oracle은 SEQUENCE 이런 식으로.</p>\n<ul>\n<li>\n<ol>\n<li>IDENTITY 전략을 쓰면 커밋 시점이 아닌 em.persist() 시점에 즉시 INSERT 문을 실행하고 DB로부터 식별자를 리턴 받아온다. 그래서 IDENTITY 전략 쓰면 영속성 컨텍스트의 장점 중 하나인 ‘지연 쓰기’ 기능 사용할 수 없으나 성능에 큰 영향은 없다.</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>SEQUENCE 전략을 쓰면 em.persist() 시점에 DB의 시퀀스로부터 next val을 받아와서 영속성 컨텍스트의 1차 캐시에 id값을 저장하게 되지만 INSERT문은 커밋 시점에 한 꺼번에 실행가능하다. 하지만 이 경우 persist마다 call next val을 해야 하는 성능 상의 문제가 있는데, allocationSize 설정을 통해 해결할 수 있다.</li>\n</ol>\n</li>\n</ul>\n<hr>\n<p>참고자료</p>\n<ul>\n<li><a href=\"https://www.inflearn.com/course/ORM-JPA-Basic\">https://www.inflearn.com/course/ORM-JPA-Basic</a></li>\n</ul>","excerpt":"JPA의 내부동작, 즉 영속성 컨텍스트의 정의, 장점, 라이프사이클 등에 대해서\b 이전 글을 통해 알아 봤다면,\n이제 Entity 매핑을 실제로 어떻게 하는 지를 알아보자. 1. 객체와 테이블 맵핑 ( @Entity, @Table ) @Entity가 붙은 클래스는 JPA가 관리하게 된다. Entity 작성 시 주의사항 기본 생성자는 필수이다. final, enum, interface, inner 클래스 사용 X 저장할 필드에 final 사용 X @Table은 엔티티와 맵핑할 테이블 지정 가능 2. DB 스키마 자동 생성 JPA에서는 DDL을 앱 실행 시점에 자동 생성해준다. ( 운영 환경에서는 사용하면 안됨 ) : JPA가 테이블 중심이 아닌 객체 중심임을 보여준다. persistence.xml에서 아래와 같이 옵션이 설정되어 있어야 한다. 여기서 value값에 옵션을 지정해주는데 옵션의 종류는 아래와 같다. create : 기존테이블 삭제 후 다시 생성(DROP + CREATE)…","frontmatter":{"date":"March 08, 2022","title":"[JPA] 4. 엔티티(Entity) 매핑 기초","categories":"Spring","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/jpa4/"}},"next":{"id":"594c5566-4632-5c70-9fdd-731673898ad2","html":"<blockquote>\n<p>지난 글에서는 JPA 프로그래밍시, EntityManager를 생성하여 persist, set 등의 CRUD 작업을 수행하는 것을 알아보았다.\n지난 글에선 설명하지 않았지만 EntityManager가 데이터를 persist 하게 되면 데이터는 ‘영속성 컨텍스트’에 저장되게 된다.\nJPA에서 가장 중요한 것은</p>\n<ol>\n<li>객체와 관계형 DB의 맵핑 문제,</li>\n<li>그리고 <strong>영속성 컨텍스트</strong>이다.</li>\n</ol>\n</blockquote>\n<h2 id=\"영속성-컨텍스트란\" style=\"position:relative;\"><a href=\"#%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80\" aria-label=\"영속성 컨텍스트란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>영속성 컨텍스트란?</h2>\n<p>영속성 컨텍스트를 이해하기에 앞서, EntityManager(이하 EM)와 EntityManagerFactory(이하 EMF)가 동작하는 방식에 대해서 먼저 이해해야 한다.</p>\n<p>EMF는 고객의 요청이 올 때 마다 EM을 생성하고 EM은 내부적으로 DB 커넥션을 사용해서 DB를 사용한며, 이를 도식화하면 아래와 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABhElEQVQoz22Ty27CQAxF8/+f0lXVbrroHolGilgQlPAIgfAMhKdAUUJcHauepqIjWR7P2NfX9ozXNI2wDoeDbDYb2e/3stvtnEynUxkOh6qx8UOKolB7u93K4/FQDLA8A8QBx8vlIufzWYV9HMcSBIEMBgPJskxlPp/Ler3W+zzPpa7r/wERgE6nk5Pb7SZVVcnxeNTgbrcrvu+7ap4A5WdxaYBthpzBivJMW8kkfAK83+/Kgkscr9er26Mnk4mMRiMNBIwkbaGHfwAJgj4B9AUHepSmqcxmM0mSxA0I1jBbrVbqi825DYXl4bBcLvUCRzRg4/FYJ7tYLFSsp/hwD3PiACYGUtgKiEGpNB6NlGXp+kfJ1lNaYewB7fV6qjkH3LM+WAb2MIuiSPr9vivZyoQ5jGmL+RsGBDymyyWGHeIIAwIBITtAgCJhGOq7pKJ2Dztfvng2VQO0n4Bz+1e0bQgYCRIwZSb88vr++w4JMEbGxKR9xp72kByb16Gfo2nk7eNTvgEG0YbuhAZ9SwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image1\"\n        title=\"image1\"\n        src=\"/static/235f571f658ac98a2d5eb5d301054e55/37523/image1.png\"\n        srcset=\"/static/235f571f658ac98a2d5eb5d301054e55/e9ff0/image1.png 180w,\n/static/235f571f658ac98a2d5eb5d301054e55/f21e7/image1.png 360w,\n/static/235f571f658ac98a2d5eb5d301054e55/37523/image1.png 720w,\n/static/235f571f658ac98a2d5eb5d301054e55/612f7/image1.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그렇다면 영속성 컨텍스트란 무엇인가?</p>\n<p>“Entity를 영구 저장하는 환경”이라는 뜻이다.\n영속성 컨텍스트는 논리적인 개념이며 또한 EM과 1대1로 대응하고, EM을 통해 접근/관리 한다.</p>\n<p>우리가 앞서 JPA에서 아래와 같이 실행하면 JPA에서 DB에 객체를 저장한다 정도로 이해했지만</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">em<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>entity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n<p>정확히는, ‘EM을 통해 Entity를 영속성 컨텍스트에 저장한다’ 는 것을 의미한다.\n그리고 추후에 공부하겠지만 Spring에서는 EM과 영속성 컨텍스트가 아래와 같이 N:1로 생성된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 92.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACXUlEQVQ4y6VUyY7aQBDl/z+EMxeQOCAkQOwJYRix2GDAwzpgG9vYZjG86NWkDeQQjZSSSk23q14tr4rU/X4HlcLzer0ijmM5b7cb2u028vk8qtUq0uk0xuOx2Co72jxjpBQQ5Xw+o9vtYj6fYzAYwDAMATBNU+7T6RTD4VBO6mazged5UEKclAJTDyqiEt6ZCd8ulwvCMITjOHBdF1EUIQpDAWUyLxn6vg/bthM9nU5iREAqnQhAIAIeDgdRvlO3n58PQGZgfnygP+hLaf1+H8Z0ir1lYbffYW6aGGm6BGUbdF2XVvC3pmkShEkIoGooywnCELZjIwgCufOdmTKjOL6KI7Nm2cfjMcnOsqwHIP5T/u55ivT3ej00Gg2JxHLK5bKUzZEpFosolUqo1WqYzWaoVCpi32w2USgUxI6TwdEi8wI4Go2kd8vlUuaNADzplM1mkcvlBLjVaiGTyaDT6UgAAhKMfazX61itVq8ls2+LxQIH18V+v39hnTNHVvm+2+2SHpL5Z0lYJqPb7VZOOtGQAb4jz/ObAK7Xa9kCNTbsB4GZFb8rAsg6WWZAMq5UTUuyKewly7BsWxzUOwNNDEPmlDZhFMHzfByDANGf4WeLSGhSMg3pQHLIMrPk/rJ89o5DXqnWJOBkMhESONhU+hzcg9i+ZMisuD5kmk3nEDMQhfe39/dkoF3Xk++yhskK+vjx6+0rQ/aG20BSSD3LpCNVEUQbAqoefrHsC9O240h25XrzAbhcrTDSNGi6LmXzL4xl8Nt3pdb6+fr3dY1jBEGYlPo8Fv9SFbRSb+E3lShVQm2ypHgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image2\"\n        title=\"image2\"\n        src=\"/static/97bb47b20fe5870806a368b0f256624d/37523/image2.png\"\n        srcset=\"/static/97bb47b20fe5870806a368b0f256624d/e9ff0/image2.png 180w,\n/static/97bb47b20fe5870806a368b0f256624d/f21e7/image2.png 360w,\n/static/97bb47b20fe5870806a368b0f256624d/37523/image2.png 720w,\n/static/97bb47b20fe5870806a368b0f256624d/612f7/image2.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<h2 id=\"영속성-컨텍스트에서-엔티티의-생명주기\" style=\"position:relative;\"><a href=\"#%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%EC%97%94%ED%8B%B0%ED%8B%B0%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0\" aria-label=\"영속성 컨텍스트에서 엔티티의 생명주기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>영속성 컨텍스트에서 엔티티의 생명주기</h2>\n<p>영속성 컨텍스트 내에서 Entity의 생명주기를 도식화하면 아래와 같다.\nnew, managed, detached, removed 의 4가지 상태가 존재한다.</p>\n<br>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.22222222222221%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABYUlEQVQ4y42TW6+CQAyE+f9/jJj46IuXKAqIF1AQ5ar25GtSwlE0NtnsLnSnM9NdRwbi+Xzq/Hg85HQ6SRiGEkWRHA4HaZrmX85rON8AmdM0leVyKYvFQrbbrdR13f0bAv0KCBsG7AAdynkDtEr9gVQCuaPRSFarlcRxrPv9ft/977O0eZChxe12E9d1xff9DnC3272B9Nk69/tdyrJUb6qq0upJkuiwuFwuMpvN5JM9/eGQTPc8z5M8z3WNRPZ4R4dpCB7ClMYQSB+Px29eOkVRdN4ADkurjOTz+SxBEMhkMpHj8ajFKMo3ihGcAQelHz3sV6bTsLNo21bB1+u1KpnP5+otRQa7bGBZlilzpHOA2SSbPdPpVEGv16uqcV6N7bMjCTtIBJBGUcRkmkXGjoI/SQbQLja3AiBrFnuLumm+vxR7yzQCDwFhbxcbMNaWX9X1b4CbzUYBkURDXhXYGoZ/Y0E+cAKlVagAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image3\"\n        title=\"image3\"\n        src=\"/static/ea9a8f912b7dcdce56c8a18ed2be51a1/37523/image3.png\"\n        srcset=\"/static/ea9a8f912b7dcdce56c8a18ed2be51a1/e9ff0/image3.png 180w,\n/static/ea9a8f912b7dcdce56c8a18ed2be51a1/f21e7/image3.png 360w,\n/static/ea9a8f912b7dcdce56c8a18ed2be51a1/37523/image3.png 720w,\n/static/ea9a8f912b7dcdce56c8a18ed2be51a1/612f7/image3.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3 id=\"1-비영속--new--transient-\" style=\"position:relative;\"><a href=\"#1-%EB%B9%84%EC%98%81%EC%86%8D--new--transient-\" aria-label=\"1 비영속  new  transient  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 비영속 ( New / transient )</h3>\n<p>: Entity가 영속성 컨텍스트와 전혀 관계없는 상태를 말한다. 아래와 같은 코드에서는\nEM을 통해 Entity에 아무런 조작도 하지 않은 상태이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 객체 생성한 상태 </span>\n<span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setId</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"2-영속--managed-\" style=\"position:relative;\"><a href=\"#2-%EC%98%81%EC%86%8D--managed-\" aria-label=\"2 영속  managed  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 영속 ( managed )</h3>\n<p>: 영속성 컨텍스트에 의해 관리되는 상태이며, persist 명령어를 통해 new -> managed 상태로 변경된다.\npersist를 할 때 Entity가 영속성 컨텍스트에 저장되는 것이지, DB에 저장되는 것은 아님에 유의하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setId</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nem<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 객체를 저장한 상태 (영속) 이 때 DB에 저장되는 것은 아니다. </span></code></pre></div>\n<h3 id=\"3-준영속--detached-\" style=\"position:relative;\"><a href=\"#3-%EC%A4%80%EC%98%81%EC%86%8D--detached-\" aria-label=\"3 준영속  detached  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 준영속 ( detached )</h3>\n<p>: 영속성 컨텍스트에 저장되었다가 분리된 상태를 말한다.\n준영속 상태로 만드는 방법은 detach, clear, close가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">//준영속 상태로 만드는 법 3가지</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">detach</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//특정 entity만 준영속 상태로 전환</span>\n<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//영속성 컨텍스트 전체를 초기화</span>\n<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//영속성 컨텍스트를 종료</span></code></pre></div>\n<h3 id=\"4-삭제--removed-\" style=\"position:relative;\"><a href=\"#4-%EC%82%AD%EC%A0%9C--removed-\" aria-label=\"4 삭제  removed  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 삭제 ( removed )</h3>\n<p>: 영속성 컨텍스트에서 삭제된 상태를 말한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">em<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n<h2 id=\"어플리케이션과-db사이에-영속성-컨텍스트를-두는-이유\" style=\"position:relative;\"><a href=\"#%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC-db%EC%82%AC%EC%9D%B4%EC%97%90-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EB%91%90%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"어플리케이션과 db사이에 영속성 컨텍스트를 두는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어플리케이션과 DB사이에 영속성 컨텍스트를 두는 이유</h2>\n<p>그렇다면 왜 Application과 DB사이에 영속성 컨텍스트라는 중간 계층을 두는 것일까?\n바로 다음과 같은 이점이 있기 때문이다.</p>\n<h3 id=\"1-1차-캐시\" style=\"position:relative;\"><a href=\"#1-1%EC%B0%A8-%EC%BA%90%EC%8B%9C\" aria-label=\"1 1차 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 1차 캐시</h3>\n<p>영속성 컨텍스트 내부에 존재하는 캐시를 의미하는데, 영속성 컨텍스트 내부에 존재하는 모든 Entity는 Map(key, value) 형태로 1차 캐시에 저장된다.\n여기서 key는 @Id로 매핑한 식별자이고 value는 Entity 객체이다.</p>\n<p>(1) 아래의 코드에서 처음 id=1인 Member Entity를 persist시에 Entity는 1차 캐시에 저장되게 되고,\n만약에 그 후에 id=1인 Member를 find하게 되면 DB가 아닌 영속성 컨텍스트의 1차 캐시로부터 조회해오게 된다.\n즉, 이 과정에서 DB에 대한 접근은 전혀 없다.</p>\n<p>(2) 또는, id=1인 Member Entity가 DB에 저장되어 있는 상태에서 이를 소스 상에서 불러오고 싶을 때,\n처음 불러올 때는 DB로부터 조회해와서 1차 캐시에 Entity로 저장하게 되고, 2번 째 동일한 Entity를 불러오게 되면\nDB접근 없이 1차캐시로부터 조회해온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// (1) </span>\n<span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setId</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nem<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//1차 캐시에 저장됨</span>\n<span class=\"token class-name\">Member</span> findMember <span class=\"token operator\">=</span> \bem<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 1차 캐시로부터 조회함(DB 접근 X)</span>\n\n<span class=\"token comment\">// (2) </span>\n<span class=\"token class-name\">Member</span> findMember1 <span class=\"token operator\">=</span> \bem<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// DB로부터 조회 (SQL 날림)</span>\n<span class=\"token class-name\">Member</span> findMember2 <span class=\"token operator\">=</span> \bem<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1차캐시로 부터 조회</span></code></pre></div>\n<br>\n<p>이처럼 동일한 transaction안에서는 캐싱을 해주는 이점이 있으나, 말 그대로 개별 transaction안에서만 캐싱이 되고, transaction이 끝나면 영속성 컨텍스트를 지우기 때문에 엄청난 성능 이점이 있는 것은 아니다. 그러나 비즈니스 로직이 굉장히 복잡한 경우에 도움이 될 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWklEQVQoz2WS246CUAxF+f+vMj4z6IMJ3hAFvAOCQIxC6GTVqaPxJM0px3a1u9Xp+144l8tF0jSVPM/Vj+NYlsul2mq1evnr9VqyLNM47Hw+S9u2yoDlGBAYoOv1KnVda6Lv+zKdThU0n89lNptJEARSluUrDuD9fv8Hyt8pikKDmqaRqqr0vt1u6vPOjQHhNugXkHYJQlYURSr1eDxqt0mSqIVhKJPJRA6Hg8YgmQYAfwG7rlN5g8HgZQBI5t3zPC2w3+/FdV0ZDodalBGZ5MfjYUKfkoG+Dx1bLBba9Xa71Q4A8k2x3W73AWQ5vKHiY4YE2NwA8IZ0kpBqywFswNPppEDmWZaFOMihI7a32Wy0El3xPRqNdMsA7W/EpoHyO2MxeNPUEsWJOFYZiTb88XisYIrRAd2yHKAYvskklhwKuD/eUzIzIpFAgjB8itnmDfQOxihmJ81y+QWxr+j1wZRJYQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image4\"\n        title=\"image4\"\n        src=\"/static/a4e7e683cc034c586d47610f6f465132/37523/image4.png\"\n        srcset=\"/static/a4e7e683cc034c586d47610f6f465132/e9ff0/image4.png 180w,\n/static/a4e7e683cc034c586d47610f6f465132/f21e7/image4.png 360w,\n/static/a4e7e683cc034c586d47610f6f465132/37523/image4.png 720w,\n/static/a4e7e683cc034c586d47610f6f465132/612f7/image4.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<h3 id=\"2-동일성-보장\" style=\"position:relative;\"><a href=\"#2-%EB%8F%99%EC%9D%BC%EC%84%B1-%EB%B3%B4%EC%9E%A5\" aria-label=\"2 동일성 보장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 동일성 보장</h3>\n<p>영속성 컨텍스트를 쓰게 되면 영속된 Entity의 동일성을 보장한다.</p>\n<p>마치 자바 컬렉션에서 객체를 꺼내온 것처럼. 이게 가능한 이유가 1차 캐시 덕분이다.\n즉 1차 캐시를 통해 repeatable read 등급의 트랜잭션 격리 수준을 DB가 아닌 애플리케이션 차원에서 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> member1 <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// DB로부터 조회</span>\n<span class=\"token class-name\">Member</span> member2 <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1차 캐시에서 꺼내오는 동일한 Entity</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>member1 <span class=\"token operator\">==</span> member2<span class=\"token punctuation\">)</span> <span class=\"token comment\">// true</span></code></pre></div>\n<h3 id=\"3-transactional-write-behind--트랜잭션-쓰기-지연-\" style=\"position:relative;\"><a href=\"#3-transactional-write-behind--%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%93%B0%EA%B8%B0-%EC%A7%80%EC%97%B0-\" aria-label=\"3 transactional write behind  트랜잭션 쓰기 지연  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Transactional write-behind ( 트랜잭션 쓰기 지연 )</h3>\n<p>persist를 하게 되면 바로 SQL을 DB로 날리는 것이 아니라, 2가지 동작을 하게 된다.</p>\n<p>(1) INSERT SQL을 생성하여 ‘쓰기 지연 SQL 저장소’에 저장한다.\n(2) 1차 캐시에 저장한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB00lEQVQ4y42T2Y6qQBRF+f+v88GBgAwi4AQqDlEc2J112rK9pmPfSrZVYrHOtPWu16vattW5bdVeWp1OJ9PlchFrvV6rrmttNhsVRaEwDBXHse2LxcJ+r6pKTdPYfa+uKsVhqDSKlKWpAt+XPxiqyHN1XWcvcHm/32u1Wmk+n2s2mxkcEIEc2ID22enXtdvtNBwO5fu+8jxXmqZPAcqyTEmSGJDvBiQLeLa/iHW73ewy4mWyIgjZsgOjfCogezL23kHvUCLzMgIYBIGm06miKDJRAc+4B9j7rdRXIL3Zbrd22Q2IHk4mEzsD7ff7dv4p+UOGQFyZ6HA4WDY44Xg82nee/zuUD4u+MFn66Pq0XC7tWVmWJlpBFQZsz2cdiPzQrmnUbLYWlUUpgNgZDBPHg+xAeU6Apw/Xda1kHCqLExXZVFEQKBz5mpWlTRmY8yIAskFkBozMAD5t86lcLg8GA5skPiRDdkTp2IbfgD8zpPn3+10depzvj7OzjTMxIAbEMMgOgwPk7KbvdY8/yre5v+Ws46ZM9FcfAsLQWIdeIoLS9z996AwLkDMBKBEg/R2NRur1ej8+/AtIr4AAo6fIDQcrjcdjgwL/LyAg5793vfrS2ewLHozEJ6UNdy8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image5\"\n        title=\"image5\"\n        src=\"/static/5b0439356719f16bb64421babcf95c96/37523/image5.png\"\n        srcset=\"/static/5b0439356719f16bb64421babcf95c96/e9ff0/image5.png 180w,\n/static/5b0439356719f16bb64421babcf95c96/f21e7/image5.png 360w,\n/static/5b0439356719f16bb64421babcf95c96/37523/image5.png 720w,\n/static/5b0439356719f16bb64421babcf95c96/612f7/image5.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이렇게 쓰기 지연 SQL 저장소에 SQL을 계속 모아두다가 transaction.commit()을 하는 순간,</p>\n<p>‘쓰기 지연 SQL 저장소’에 있던 쿼리들이 flush가 되면서 DB에 날라가고 커밋된다.</p>\n<blockquote>\n<p>flush()는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업으로 등록, 수정, 삭제한 Entity 를 데이터베이스에 반영한다.</p>\n</blockquote>\n<p>이렇듯 버퍼링을 모아서 write하기 때문에 <strong>지연 쓰기를 통해 배치 쿼리를 짜는 경우에 이점</strong>을 얻을 수 있다.</p>\n<h3 id=\"4-dirty-checking-변경-감지\" style=\"position:relative;\"><a href=\"#4-dirty-checking-%EB%B3%80%EA%B2%BD-%EA%B0%90%EC%A7%80\" aria-label=\"4 dirty checking 변경 감지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Dirty Checking (변경 감지)</h3>\n<p>영속성 컨텍스트에는 이전 flush 때의 Entity 상태를 복사해서 저장해둔 스냅샷이 존재하며,\nflush 시점에 이전에 저장해둔 스냅샷과 Entity를 비교해 변경된 Entity를 찾는다.</p>\n<p>그리고 변경된 Entity를 찾아 각 Entity 객체에 대한 update SQL을 생성하여 ‘쓰기 지연 SQL 저장소’에 저장하고,\n한 꺼번에 DB로 쿼리를 날리면서 transaction을 커밋한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmebmer<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"modified\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//이렇게만 해도 커밋 시 UPDATE문이 날라간다. </span></code></pre></div>\n<br>\n<blockquote>\n<h2 id=\"flush-란\" style=\"position:relative;\"><a href=\"#flush-%EB%9E%80\" aria-label=\"flush 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>flush 란?</h2>\n<p>영속성 컨텍스트가 변경사항을 DB에 동기화하는 작업을 말하며 다음과 같은 경우에 flush가 발생한다.</p>\n<ol>\n<li>transaction commit 될 때</li>\n<li>EntityManager가 직접 flush() 호출할 때</li>\n<li>JPQL 쿼리가 실행될 때</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABqklEQVQ4y22T147CQAxF8/+/xVsUJIroHQKEThI6Il6dKzlitTuSNSWe42uPE7zfb9vtdnY8Hu1wOMhms5mNx2ObTqeyyWSiGb/T6STf/X5veZ4boygK8xE8n0/bbrd2uVzser1qHo1G1uv1rN/vCzwYDKzT6QiWZZlAaZoK/Af4er0UDWWLxcLiOJYSgnC2Xq/LNWCg7PE5n8+/gMwCzudzqUKRGwpJFchqtZK1222BfY9KHw4NSLHRaFi321UKj8fDbrebZtTc73edkzrq8WMGCJySUSrG5/OxgAvL5VI1qtfrUoVaZtIFSgCMi15nvvF4w+FQawTAUcpeEyJzSGo4+msCpV6k6K/MjD/nBOcO4gRMkkTyqRv1xIHoYRgqVRRQy2q1qlT9tTebjfatVstqtZpaS0AuYDwGUVECOIoiAVHdbDatUqmoEwgOEBj3AKGUdanQP3qaqCQy9QTOYxCAy/gQ1Nvme5RAlOEMlHoCAoKhkk5AIecAUUjq3jJuAqKOegDmgYByRh1JF0MxcNakDPT7Tyn7kN4B5Bf/M29kD8QZGXn/ff96P43hy55L507OAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image6\"\n        title=\"image6\"\n        src=\"/static/2dd945ba9e5a5cd17e843887eb00b5d1/37523/image6.png\"\n        srcset=\"/static/2dd945ba9e5a5cd17e843887eb00b5d1/e9ff0/image6.png 180w,\n/static/2dd945ba9e5a5cd17e843887eb00b5d1/f21e7/image6.png 360w,\n/static/2dd945ba9e5a5cd17e843887eb00b5d1/37523/image6.png 720w,\n/static/2dd945ba9e5a5cd17e843887eb00b5d1/612f7/image6.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</blockquote>\n<h3 id=\"5-lazy-loading--지연-로딩-\" style=\"position:relative;\"><a href=\"#5-lazy-loading--%EC%A7%80%EC%97%B0-%EB%A1%9C%EB%94%A9-\" aria-label=\"5 lazy loading  지연 로딩  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Lazy Loading ( 지연 로딩 )</h3>\n<p>Lazy Loading이란 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다.\nLazy Loading을 통해 자바의 컬렉션처럼 DB를 사용하면서도 필요한 만큼의 데이터만 DB로부터 불러오도록 할 수 있다.</p>\n<p>이에 대해선 추후에 더 알아보도록 하자.</p>\n<hr>\n<p>참고자료</p>\n<ul>\n<li><a href=\"https://www.inflearn.com/course/ORM-JPA-Basic\">https://www.inflearn.com/course/ORM-JPA-Basic</a></li>\n</ul>","frontmatter":{"date":"February 27, 2022","title":"[JPA] 3. JPA 내부동장 방식 : 영속성 관리","categories":"Spring","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/jpa3/"}},"prev":{"id":"c7e517d4-5e33-5d3e-8aa2-451e7b99ae12","html":"<p>JPA 연관관계 매핑을 배우기에 앞서, 객체와 테이블의 연관관계를 맺는 방법이 다르다는 것을 이해해야 한다.\nJPA 1. 에서 언급했듯이, 객체는 참조를 통해, 테이블은 FK를 통한 조인으로 연관관계를 맺는다.</p>\n<p>회원과 팀이 다대일 관계일 때 객체를 테이블에 맞추어 모델링 한다면 아래와 같을 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABpklEQVQoz4WT56oiURCEff+X8Y+YrqgggiLmhDnnnLN1+XpRZFnchoNjT3V1dfUZh77E7XZTt9vVeDzWYDBQv9/XaDT6ViLH4/HQ5XLR6XTSbrfT8XjU+Xy2HM8QQdjr9Yx8MpmIGjD7/d4wYPlP3kGi2WxqNpspEAjI5/Mpk8loPp+bon8F72hQr9fldrsN1+l0dDgc5IA9Ho+/SRmT3PV6fat5Pp92eCbApdNpLRYLUwmeKYyQwmAwKI/Ho1gspuFwqM1mo9VqZeO+yD4Jt9utUqmUCoWC2YDaVqtlxI77/W5Gc3iB/Ol0ah0p/F9Q/5rClvINTMdarWYqaMQvSlD/d7wJGRkAqnK5nC0EEtSRQzlqWQS/+AYeW7CHGjDL5fLPyFyXbDarZDIpp9Mpl8ulcDisarVqHr4CHFeDW4HKcrlsPrLlRCKhSqViCzKFPz8/RhSJRBQKhQyAmnw+b9eB7mwWUorI0RQsz1hBgzdhNBqV1+u1e+j3+9VoNGw0gK/NfgZKi8WiSqWSEeJvu922vH0pePLyZb1e24EQRS/DP8+3T+8X4wKHHPXfanAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image1\"\n        title=\"image1\"\n        src=\"/static/e02aa46a2594edb30559c00d2ec684bb/37523/image1.png\"\n        srcset=\"/static/e02aa46a2594edb30559c00d2ec684bb/e9ff0/image1.png 180w,\n/static/e02aa46a2594edb30559c00d2ec684bb/f21e7/image1.png 360w,\n/static/e02aa46a2594edb30559c00d2ec684bb/37523/image1.png 720w,\n/static/e02aa46a2594edb30559c00d2ec684bb/612f7/image1.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<p>그리고 이렇게 Entity 상에서 이렇게 매핑을 하게 되면 서로 연관된 데이터를 가져오고 싶을 때</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> findMember <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> member<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Team</span> findTeam <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Team</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> findMember<span class=\"token punctuation\">.</span><span class=\"token function\">getTeamId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n<p>이렇게 Id를 통해서만 가져올 수 있게 된다. 그리고 이것은 객체지향스럽지 않은 방식이다.\nJPA에서는(ORM에선) 이를 어떻게 모델링 할 수 있을까?\nJPA에서는 단방향, 양방향 연관관계를 통해 객체지향적으로 프로그래밍이 가능하도록 해준다.</p>\n<h2 id=\"1-단방향-연관관계\" style=\"position:relative;\"><a href=\"#1-%EB%8B%A8%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84\" aria-label=\"1 단방향 연관관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 단방향 연관관계</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABlklEQVQoz32S16oCQRBE5///xwD6oCAqKqKYMWfFnLN1OQ27COIdaHZmtru6q2qcJL3fb/23ptOput2uBoOB2u22hsPhz1zngV0uFx0OByumiOL9fq/NZqPFYqHZbGbBf87cH49HjUYj9ft9bbdby3ceMsmAdDodJZNJZbNZKySZ4uv1ak1Xq5WdG42G3zyXy2m9XtvkbjweG1CtVlM8Hlez2VS9XjcAFp1vt5vtn8+nTqeT7QFOpVLWkDsfkAvWbrezToVCQZlMxhInk4l6vZ4ej8eXVjRkQnLm87kFkzsmI5iKAJCfr9fLigBjQuJ+v9uX+19GunK5bHrl83mxTyQSNhXFFJ7PZ5OhVCqZXq1WS5VKRcvl0sAxBsrkke9wyXOZpGKxqGAwqHA4bAZByZsGDQFhelhgJIwCgYA1RQJHEejQDoVCikajZk4sFrNkZEBsnhQgPA0aV6tV0xpG7GEHlkNIXIZyJBLxg0SKYUBnJPg0B/fT6bTJRT2BVP47hDJj04UvU0EXWp8L+gS0PZNgiI7s/wDjnDOvInCJCgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image2\"\n        title=\"image2\"\n        src=\"/static/42f00aa8f5e469244bb23504ffda6698/37523/image2.png\"\n        srcset=\"/static/42f00aa8f5e469244bb23504ffda6698/e9ff0/image2.png 180w,\n/static/42f00aa8f5e469244bb23504ffda6698/f21e7/image2.png 360w,\n/static/42f00aa8f5e469244bb23504ffda6698/37523/image2.png 720w,\n/static/42f00aa8f5e469244bb23504ffda6698/612f7/image2.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Entity 클래스에서 참고하고자 하는 다른 Entity 클래스의 참조형을 멤버변수로 선언하는데,\n이 때 참조형으로 생성하는 Entity는 FK를 가지고 있지 않은 쪽 ( ‘Many’ 인 쪽 ) 이다.\n즉 Team과 Member와의 관계에서는 Team이 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Id</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@ManyToOne</span>\n    <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"team_id\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러면 이제 우리는 객체지향적으로 아래와 같이 코드를 짤 수 있다.\n즉, 객체 그래프 탐색이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> findMember <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> member<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Team</span> findTeam <span class=\"token operator\">=</span> findMember<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//이게 된다.</span></code></pre></div>\n<h2 id=\"2-양방향-연관관계\" style=\"position:relative;\"><a href=\"#2-%EC%96%91%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84\" aria-label=\"2 양방향 연관관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 양방향 연관관계</h2>\n<p>위의 예에서는 Member.getTeam()은 할 수 있었지만, 즉 member가 team을 참조할 순 있었지만</p>\n<p>Team이 Member를 참조할 수는 없었다. 그래서 그걸 해보려면 아래와 같이 객체 연관관계 매핑 시에 Team 클래스에는 List members 가 추가되어야 한다.</p>\n<p>반면, 테이블 연관관계는 단방향 일 때와 차이가 없다. 테이블에서 FK로 연관관계를 맺을 때는 방향성이 없고 그냥 FK로 join걸면 서로 연관된 데이터를 모두 가져오게 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpklEQVQoz4VS12pCURA8//8jvgj6YEFULAiiiL037L33PskM3JCESBYOnLa7U9bgTYzHY2QyGZRKJXQ6HRQKBbRaLRSLRZTLZXS73T/zzGKxwGazUUIul0M+n8dkMsF8PlcBvh+PR+x2O/3bbre66/f7ums0GshmswKwXq9hWGi1WiGdTiORSCAWi6k774jOang4HLDf75U4Go2Envt6vY5QKCQWBGH4UK1WVZ2Fns/nF3wW/R1E+3q9hHAwGOByufyknEwm4fV6EY1G4Xa79ZHFl8sler2ekrnY6HszaunxeBAMBsXK5/NJMsMuLMJFKhal4XAojd7FbDaTfu12W7QrlYr2Bv8EkRIxdeTimbTfhSEN6nA6naQZhaUR1+tVjrI7kVBful6r1TCdTnG/32US/zKXNW63GwwT+ZkuuVwuOBwOBAIBJf6eNUtDFmk2m3LabrcjHA6LLgGZx+OBVCoFp9MJv98vczgG1kxSS44MZ5OISZ+IaYjNZkM8HpcpNJf6G0Ln2LBLJBJRMc4m7+kyNTufzzpbwTObcXbJjM1o6uxzDj8AyDouDpZFei8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image3\"\n        title=\"image3\"\n        src=\"/static/fe327661c5c61d9b0765b87c8cd5a9f0/37523/image3.png\"\n        srcset=\"/static/fe327661c5c61d9b0765b87c8cd5a9f0/e9ff0/image3.png 180w,\n/static/fe327661c5c61d9b0765b87c8cd5a9f0/f21e7/image3.png 360w,\n/static/fe327661c5c61d9b0765b87c8cd5a9f0/37523/image3.png 720w,\n/static/fe327661c5c61d9b0765b87c8cd5a9f0/612f7/image3.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<p>문제는 객체의 연관관계다. 객체에서는 Team에서 Member로 참조할 수 있게 하기 위해 Member 타입의 List를 넣어주어야 Team이 Member를 참조할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Id</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@OneToMany</span><span class=\"token punctuation\">(</span>mappedBy<span class=\"token operator\">=</span><span class=\"token string\">\"team\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">></span></span> members <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러면 아래처럼 양방향으로 참조가 가능하게 된다.</p>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> findMember <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> member<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">></span></span> members <span class=\"token operator\">=</span> findMember<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//이게 된다</span></code></pre></div>\n<br>\n<h3 id=\"그런데-mappedby가-무엇인가연관관계의-주인\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9F%B0%EB%8D%B0-mappedby%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84%EC%9D%98-%EC%A3%BC%EC%9D%B8\" aria-label=\"그런데 mappedby가 무엇인가연관관계의 주인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그런데 mappedBy가 무엇인가?(연관관계의 주인)</h3>\n<p>객체와 테이블의 연관관계의 차이에 대해서 다시 짚어보자.</p>\n<ul>\n<li>\n<ol>\n<li>\n<p>객체는 Member -> Team , Team -> Member 의 단방향 관계 2개로 양방향 관계를 맺는다.</p>\n<p>즉, 객체의 양방향 관계는 사실 서로 다른 단방향 관계 2개이다.</p>\n</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>반면 테이블은 TEAM_ID 라는 1개의 값으로 양방향 관계를 맺는다.</li>\n</ol>\n</li>\n</ul>\n<p>따라서 객체에서는 양방향 관계 중 Member의 team으로 FK를 관리할 지 Team의 members로 FK를 관리할 지를 정해주어야 한다.</p>\n<ul>\n<li>객체의 두 관계 중 하나를 주인으로 지정(FK관리)해주어야 한다는 것이다.</li>\n<li>주인이 아닌 쪽은 Read-only이며 따라서 Team의 members에 뭔가 데이터를 넣고 Team을 저장한다고 해서 Member 테이블에 데이터가 쌓이지 않을 것이다.</li>\n<li>mappedBy 속성으로 주인을 지정해주어야 한다.</li>\n</ul>\n<br>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXUlEQVQoz42Sx24CUQxF399nwc/Mii0IECA2VNH7CJihiN7LjY6TQdkgxZLlKbZvec/pN9brtTabjdrtttLptPL5vMIw1Gw2s7rb7ez/crnUarVSt9vVYrFQo9Gw/vl8riAI5B6Ph0jf99VqtWyYZur9fjeg7XYb4Wq/3+t8PttiwAHiGwGAOxwOul6vmkwmymazyuVySqVS74XT6VSdTufNkOXM9Pt9JRIJFYtFIwJTdjjQiMvlovF4rOFwqNFoZAuRQL3dbm+Gz+dTp9PJmDebTctqtapSqfQjmYFer2cSQCV5rtfrNvg3WAaB1+ulT+GQwmBkOIjIzmQyJpf/SI98RhbJIQwGA5NKrVQq1u+Ox6Nthi5ecGLxeNz8KZfL1swwPmML/nEIzJF4GlWYm4cwrNVqtsjzPCWTSVsYeQryfwJCLnrhbnFihULB5GI014B7CDMCBp+S+IrF9A1Ktp+p2rDNqgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image4\"\n        title=\"image4\"\n        src=\"/static/ac4651bba63717b0a97fcd9efbf8248d/37523/image4.png\"\n        srcset=\"/static/ac4651bba63717b0a97fcd9efbf8248d/e9ff0/image4.png 180w,\n/static/ac4651bba63717b0a97fcd9efbf8248d/f21e7/image4.png 360w,\n/static/ac4651bba63717b0a97fcd9efbf8248d/37523/image4.png 720w,\n/static/ac4651bba63717b0a97fcd9efbf8248d/612f7/image4.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<br></p>\n<p>그렇다면 누구를 주인으로 지정해주어야 할까?</p>\n<p>비즈니스 중요성과 관계없이 무조건 FK가 있는 테이블 쪽 ( <strong>N:1에서 N인 곳</strong> ) 을 주인으로 정해야 한다.</p>\n<br>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.222222222222214%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkklEQVQoz22Sx4oDQQxE+/+/x8YHY3DEBmOcc84551jLEztmDysQ3dMjlUoluc/nI+zxeJj3ej3l83lls1lNp1O1Wi3V63U1m00Nh0ONx2PVajWlUillMhnzSCSi0Wik5/Mpp1/jATCSASsUCppMJgZ0PB7ND4eD5vO5FouFSqWS5RSLRSMwGAzU7/flLpeLrtergVWrVa1WKwt8vV5WaLPZiBg6wYmlE4rRAaw82263clQjgXbC4bCi0aj5crnUbrczhhS53W4Ght/vd7Xb7W98LBazEzkcbWBU2u/3Rj2dTpsu5XLZ9AKUDvjmjm65XE7JZFLBYFCBQMD+Ucx1Oh3Tg5NWG42GMfhrfNOmd57PZ7u/329zb7CYox2YcaJBt9s1cdHndDrZMP4zOgJ4vV5bLHfiHWAYIjNZ9AiFQtYy04axNxASSKQw75VKxdYH/ZAAWRxTBJSffr9fPp9PiUTiu1usEayJgQ06wRpACsfjcdOdDTFAqKMHj4jM5LyBwATQvxp5BlOWHnnYzdlsZiv2A+kw4JaHCyP3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image5\"\n        title=\"image5\"\n        src=\"/static/687624527312986690a0e8ee411b42aa/37523/image5.png\"\n        srcset=\"/static/687624527312986690a0e8ee411b42aa/e9ff0/image5.png 180w,\n/static/687624527312986690a0e8ee411b42aa/f21e7/image5.png 360w,\n/static/687624527312986690a0e8ee411b42aa/37523/image5.png 720w,\n/static/687624527312986690a0e8ee411b42aa/612f7/image5.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<br></p>\n<h3 id=\"양방향-매핑-시-가장-많이-하는-실수\" style=\"position:relative;\"><a href=\"#%EC%96%91%EB%B0%A9%ED%96%A5-%EB%A7%A4%ED%95%91-%EC%8B%9C-%EA%B0%80%EC%9E%A5-%EB%A7%8E%EC%9D%B4-%ED%95%98%EB%8A%94-%EC%8B%A4%EC%88%98\" aria-label=\"양방향 매핑 시 가장 많이 하는 실수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>양방향 매핑 시 가장 많이 하는 실수</h3>\n<ol>\n<li>\n<p>연관관계의 주인이 아닌 쪽에서 수정/저장을 하는 경우</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setUserName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"member1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Team</span> team <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nteam<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TeamA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nteam<span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위와 같이 코드를 실행하면 member 테이블이 가지고 있는 FK인 team_id에 데이터가 저장되지 않는다. 앞서 말했듯, 연관관계의 주인이 아닌 쪽은 ‘Read-only’이기 때문이다.</p>\n<p>그렇기 때문에 아래와 같이 연관관계의 주인인 Member 클래스에서 team을 추가해주어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Team</span> team <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nteam<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TeamA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//team.getMembers().add(member);</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setUserName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"member1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// team_id 로 매핑됨. </span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ol>\n<br>\n<ol start=\"2\">\n<li>\n<p>연관관계의 주인이 아닌 쪽에서 연관관계를 매핑하지 않는 경우</p>\n<p>아니 주인이 아닌 쪽에서는 연관관계 매핑을 하지말라며? 뭔 소리야? 라고 생각 할 수 있다.</p>\n<p>하지만 정확히는 위와 같이 연관관계의 주인이 아닌 쪽에서 사용해서 수정/저장을 하지 말라는 거지 이렇게 주인이 아닌 쪽에서 연관관계 매핑을 쓰지 말라는 뜻이 아니다.</p>\n<p>오히려 2가지 이유로 양쪽 클래스 모두에 값을 설정\b해주어야 한다. 즉 Team에서도 아래와 같이 add Member를 해주어야 한다는 뜻이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">team<span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>(1) 객체지향으로 생각해보면 team에도 add member를 해주고,member에도 team을 설정해주는게 맞다.</p>\n</li>\n<li>\n<p>(2) <strong>JPA에서는 영속성 컨텍스트의 1차캐시에서 먼저 값을 조회해오기 때문에 발생하는 이슈</strong>가 있다.\n즉 DB가 아닌 1차캐시에서 데이터를 가져오게 되면 사실 상 순수 객체 상태기 때문에 양방향 매핑이 필요하다. 아래 코드를 살펴보자.\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">  <span class=\"token class-name\">Team</span> team <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  team<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TeamA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  em<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  member<span class=\"token punctuation\">.</span><span class=\"token function\">setUserName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"member1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  member<span class=\"token punctuation\">.</span><span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// team_id 로 매핑됨. </span>\n  em<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">//team.getMembers().add(member); 이걸 주석해제 해주면 1차캐시 문제를 해결 가능</span>\n  <span class=\"token comment\">// em.flush();</span>\n  <span class=\"token comment\">// em.clear();   </span>\n\n  <span class=\"token comment\">/* 위에서 저장된 team을 DB가 아닌 영속성 컨텍스트 내의 1차캐시로부터 불러온다. (flush, clear가 안되었다면)\n  즉 반환되는 값은 순수 객체상태라고 보면 되고 따라서 team 객체의 member list는 비어 있을 것이다. \n  셋팅해준 적이 없으니깐. */</span>\n  <span class=\"token class-name\">Team</span> findTeam <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Team</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> team<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">Lis</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">></span></span> members <span class=\"token operator\">=</span> findTeam<span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span> m <span class=\"token operator\">:</span> members<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"m=\"</span><span class=\"token operator\">+</span>m<span class=\"token punctuation\">.</span><span class=\"token function\">getUserName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//아무것도 안찍힘. </span>\n  <span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>위 코드에서 Flush, clear를 해주지 않았다면 영속성 컨텍스트의 1차캐시로부터 team 객체를 가져오게 될 것이기 때문에 사실상 순수 team객체를 가지고 오는 것과 같고, team객체에는 member list에 대해서 설정해준 것이 아무것도 없기 때문에 null값을 반환하게 될 것이다.</p>\n<p>따라서 이와 같은 문제 해결을 위해 주석을 해제하여 객체 간 서로 참조할 수 있게 아래와 같이 매핑해주어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">team<span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그리고 이를 쉽게 해주기 위해 **‘양방향 편의 메소드’**를 설정해주면 좋다. 연관관계의 주인 쪽(Member)에 아래와 같이 setTeam메소드 대신 changeTeam으로 변경해주고 Member.changeTeam(team)시 Member와 Team쪽에서 모두 값이 매핑되도록 설정해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">changeTeam</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>team <span class=\"token operator\">=</span> team<span class=\"token punctuation\">;</span>\n  team<span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//양방향 매핑. </span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>반대로 연관관계의 주인이 아닌 Team쪽에서 양방향 매핑되도록 편의 메소드 설정을 해줘도 된다.\n그러나 <strong>반드시 Member 또는 Team 둘 중 한 곳에서만</strong> 편의 메소드를 설정해야 함에 주의하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">addMember</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span> member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  members<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  member<span class=\"token punctuation\">.</span><span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>(3) 양방향 매핑시 발생하는 무한 Loop</p>\n<p>toString이나 json 생성 라이브러리 사용 시에 순환 참조 문제가 발생한다.  즉 Member가 Team을 참조하고 Team안에는 또 Member가 있고 다시 그 Member안에 Team 참조…무한 반복되는 문제. toString은 쓰지 않는 것을 추천하고 json으로 controller에서 내려줄 때는 entity로 절대 반환하지 말고 DTO를 통해 response 주도록 해야 한다.</p>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>오늘의 간단 정리</p>\n<ul>\n<li>단방향 매핑만으로도 연관관계 매핑은 끝난다.</li>\n<li>양방향은 필요하면 추가하면 되고 편의메소드를 쓰면 됨.</li>\n<li>연관관계의 주인은 FK가 있는 곳이 기준이다.</li>\n</ul>\n<hr>\n<p>참고자료</p>\n<ul>\n<li><a href=\"https://www.inflearn.com/course/ORM-JPA-Basic\">https://www.inflearn.com/course/ORM-JPA-Basic</a></li>\n</ul>\n<p>​</p>","frontmatter":{"date":"March 12, 2022","title":"[JPA] 5. 연관관계 매핑 (feat. 연관관계의 주인)","categories":"Spring","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/jpa5/"}},"site":{"siteMetadata":{"siteUrl":"https://jjunyong.github.io","comments":{"utterances":{"repo":"jjunyong/jjunyong.github.io"}}}}},"pageContext":{"slug":"/jpa4/","nextSlug":"/jpa3/","prevSlug":"/jpa5/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}