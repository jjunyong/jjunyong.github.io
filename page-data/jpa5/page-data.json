{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/jpa5/",
    "result": {"data":{"cur":{"id":"c7e517d4-5e33-5d3e-8aa2-451e7b99ae12","html":"<p>JPA 연관관계 매핑을 배우기에 앞서, 객체와 테이블의 연관관계를 맺는 방법이 다르다는 것을 이해해야 한다.\nJPA 1. 에서 언급했듯이, 객체는 참조를 통해, 테이블은 FK를 통한 조인으로 연관관계를 맺는다.</p>\n<p>회원과 팀이 다대일 관계일 때 객체를 테이블에 맞추어 모델링 한다면 아래와 같을 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABpklEQVQoz4WT56oiURCEff+X8Y+YrqgggiLmhDnnnLN1+XpRZFnchoNjT3V1dfUZh77E7XZTt9vVeDzWYDBQv9/XaDT6ViLH4/HQ5XLR6XTSbrfT8XjU+Xy2HM8QQdjr9Yx8MpmIGjD7/d4wYPlP3kGi2WxqNpspEAjI5/Mpk8loPp+bon8F72hQr9fldrsN1+l0dDgc5IA9Ho+/SRmT3PV6fat5Pp92eCbApdNpLRYLUwmeKYyQwmAwKI/Ho1gspuFwqM1mo9VqZeO+yD4Jt9utUqmUCoWC2YDaVqtlxI77/W5Gc3iB/Ol0ah0p/F9Q/5rClvINTMdarWYqaMQvSlD/d7wJGRkAqnK5nC0EEtSRQzlqWQS/+AYeW7CHGjDL5fLPyFyXbDarZDIpp9Mpl8ulcDisarVqHr4CHFeDW4HKcrlsPrLlRCKhSqViCzKFPz8/RhSJRBQKhQyAmnw+b9eB7mwWUorI0RQsz1hBgzdhNBqV1+u1e+j3+9VoNGw0gK/NfgZKi8WiSqWSEeJvu922vH0pePLyZb1e24EQRS/DP8+3T+8X4wKHHPXfanAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image1\"\n        title=\"image1\"\n        src=\"/static/e02aa46a2594edb30559c00d2ec684bb/37523/image1.png\"\n        srcset=\"/static/e02aa46a2594edb30559c00d2ec684bb/e9ff0/image1.png 180w,\n/static/e02aa46a2594edb30559c00d2ec684bb/f21e7/image1.png 360w,\n/static/e02aa46a2594edb30559c00d2ec684bb/37523/image1.png 720w,\n/static/e02aa46a2594edb30559c00d2ec684bb/612f7/image1.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<p>그리고 이렇게 Entity 상에서 이렇게 매핑을 하게 되면 서로 연관된 데이터를 가져오고 싶을 때</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> findMember <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> member<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Team</span> findTeam <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Team</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> findMember<span class=\"token punctuation\">.</span><span class=\"token function\">getTeamId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n<p>이렇게 Id를 통해서만 가져올 수 있게 된다. 그리고 이것은 객체지향스럽지 않은 방식이다.\nJPA에서는(ORM에선) 이를 어떻게 모델링 할 수 있을까?\nJPA에서는 단방향, 양방향 연관관계를 통해 객체지향적으로 프로그래밍이 가능하도록 해준다.</p>\n<h2 id=\"1-단방향-연관관계\" style=\"position:relative;\"><a href=\"#1-%EB%8B%A8%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84\" aria-label=\"1 단방향 연관관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 단방향 연관관계</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABlklEQVQoz32S16oCQRBE5///xwD6oCAqKqKYMWfFnLN1OQ27COIdaHZmtru6q2qcJL3fb/23ptOput2uBoOB2u22hsPhz1zngV0uFx0OByumiOL9fq/NZqPFYqHZbGbBf87cH49HjUYj9ft9bbdby3ceMsmAdDodJZNJZbNZKySZ4uv1ak1Xq5WdG42G3zyXy2m9XtvkbjweG1CtVlM8Hlez2VS9XjcAFp1vt5vtn8+nTqeT7QFOpVLWkDsfkAvWbrezToVCQZlMxhInk4l6vZ4ej8eXVjRkQnLm87kFkzsmI5iKAJCfr9fLigBjQuJ+v9uX+19GunK5bHrl83mxTyQSNhXFFJ7PZ5OhVCqZXq1WS5VKRcvl0sAxBsrkke9wyXOZpGKxqGAwqHA4bAZByZsGDQFhelhgJIwCgYA1RQJHEejQDoVCikajZk4sFrNkZEBsnhQgPA0aV6tV0xpG7GEHlkNIXIZyJBLxg0SKYUBnJPg0B/fT6bTJRT2BVP47hDJj04UvU0EXWp8L+gS0PZNgiI7s/wDjnDOvInCJCgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image2\"\n        title=\"image2\"\n        src=\"/static/42f00aa8f5e469244bb23504ffda6698/37523/image2.png\"\n        srcset=\"/static/42f00aa8f5e469244bb23504ffda6698/e9ff0/image2.png 180w,\n/static/42f00aa8f5e469244bb23504ffda6698/f21e7/image2.png 360w,\n/static/42f00aa8f5e469244bb23504ffda6698/37523/image2.png 720w,\n/static/42f00aa8f5e469244bb23504ffda6698/612f7/image2.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Entity 클래스에서 참고하고자 하는 다른 Entity 클래스의 참조형을 멤버변수로 선언하는데,\n이 때 참조형으로 생성하는 Entity는 FK를 가지고 있지 않은 쪽 ( ‘Many’ 인 쪽 ) 이다.\n즉 Team과 Member와의 관계에서는 Team이 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Id</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@ManyToOne</span>\n    <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"team_id\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러면 이제 우리는 객체지향적으로 아래와 같이 코드를 짤 수 있다.\n즉, 객체 그래프 탐색이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> findMember <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> member<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Team</span> findTeam <span class=\"token operator\">=</span> findMember<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//이게 된다.</span></code></pre></div>\n<h2 id=\"2-양방향-연관관계\" style=\"position:relative;\"><a href=\"#2-%EC%96%91%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84\" aria-label=\"2 양방향 연관관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 양방향 연관관계</h2>\n<p>위의 예에서는 Member.getTeam()은 할 수 있었지만, 즉 member가 team을 참조할 순 있었지만</p>\n<p>Team이 Member를 참조할 수는 없었다. 그래서 그걸 해보려면 아래와 같이 객체 연관관계 매핑 시에 Team 클래스에는 List members 가 추가되어야 한다.</p>\n<p>반면, 테이블 연관관계는 단방향 일 때와 차이가 없다. 테이블에서 FK로 연관관계를 맺을 때는 방향성이 없고 그냥 FK로 join걸면 서로 연관된 데이터를 모두 가져오게 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpklEQVQoz4VS12pCURA8//8jvgj6YEFULAiiiL037L33PskM3JCESBYOnLa7U9bgTYzHY2QyGZRKJXQ6HRQKBbRaLRSLRZTLZXS73T/zzGKxwGazUUIul0M+n8dkMsF8PlcBvh+PR+x2O/3bbre66/f7ums0GshmswKwXq9hWGi1WiGdTiORSCAWi6k774jOang4HLDf75U4Go2Envt6vY5QKCQWBGH4UK1WVZ2Fns/nF3wW/R1E+3q9hHAwGOByufyknEwm4fV6EY1G4Xa79ZHFl8sler2ekrnY6HszaunxeBAMBsXK5/NJMsMuLMJFKhal4XAojd7FbDaTfu12W7QrlYr2Bv8EkRIxdeTimbTfhSEN6nA6naQZhaUR1+tVjrI7kVBful6r1TCdTnG/32US/zKXNW63GwwT+ZkuuVwuOBwOBAIBJf6eNUtDFmk2m3LabrcjHA6LLgGZx+OBVCoFp9MJv98vczgG1kxSS44MZ5OISZ+IaYjNZkM8HpcpNJf6G0Ln2LBLJBJRMc4m7+kyNTufzzpbwTObcXbJjM1o6uxzDj8AyDouDpZFei8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image3\"\n        title=\"image3\"\n        src=\"/static/fe327661c5c61d9b0765b87c8cd5a9f0/37523/image3.png\"\n        srcset=\"/static/fe327661c5c61d9b0765b87c8cd5a9f0/e9ff0/image3.png 180w,\n/static/fe327661c5c61d9b0765b87c8cd5a9f0/f21e7/image3.png 360w,\n/static/fe327661c5c61d9b0765b87c8cd5a9f0/37523/image3.png 720w,\n/static/fe327661c5c61d9b0765b87c8cd5a9f0/612f7/image3.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<p>문제는 객체의 연관관계다. 객체에서는 Team에서 Member로 참조할 수 있게 하기 위해 Member 타입의 List를 넣어주어야 Team이 Member를 참조할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Id</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@OneToMany</span><span class=\"token punctuation\">(</span>mappedBy<span class=\"token operator\">=</span><span class=\"token string\">\"team\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">></span></span> members <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러면 아래처럼 양방향으로 참조가 가능하게 된다.</p>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> findMember <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> member<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">></span></span> members <span class=\"token operator\">=</span> findMember<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//이게 된다</span></code></pre></div>\n<br>\n<h3 id=\"그런데-mappedby가-무엇인가연관관계의-주인\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9F%B0%EB%8D%B0-mappedby%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84%EC%9D%98-%EC%A3%BC%EC%9D%B8\" aria-label=\"그런데 mappedby가 무엇인가연관관계의 주인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그런데 mappedBy가 무엇인가?(연관관계의 주인)</h3>\n<p>객체와 테이블의 연관관계의 차이에 대해서 다시 짚어보자.</p>\n<ul>\n<li>\n<ol>\n<li>\n<p>객체는 Member -> Team , Team -> Member 의 단방향 관계 2개로 양방향 관계를 맺는다.</p>\n<p>즉, 객체의 양방향 관계는 사실 서로 다른 단방향 관계 2개이다.</p>\n</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>반면 테이블은 TEAM_ID 라는 1개의 값으로 양방향 관계를 맺는다.</li>\n</ol>\n</li>\n</ul>\n<p>따라서 객체에서는 양방향 관계 중 Member의 team으로 FK를 관리할 지 Team의 members로 FK를 관리할 지를 정해주어야 한다.</p>\n<ul>\n<li>객체의 두 관계 중 하나를 주인으로 지정(FK관리)해주어야 한다는 것이다.</li>\n<li>주인이 아닌 쪽은 Read-only이며 따라서 Team의 members에 뭔가 데이터를 넣고 Team을 저장한다고 해서 Member 테이블에 데이터가 쌓이지 않을 것이다.</li>\n<li>mappedBy 속성으로 주인을 지정해주어야 한다.</li>\n</ul>\n<br>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXUlEQVQoz42Sx24CUQxF399nwc/Mii0IECA2VNH7CJihiN7LjY6TQdkgxZLlKbZvec/pN9brtTabjdrtttLptPL5vMIw1Gw2s7rb7ez/crnUarVSt9vVYrFQo9Gw/vl8riAI5B6Ph0jf99VqtWyYZur9fjeg7XYb4Wq/3+t8PttiwAHiGwGAOxwOul6vmkwmymazyuVySqVS74XT6VSdTufNkOXM9Pt9JRIJFYtFIwJTdjjQiMvlovF4rOFwqNFoZAuRQL3dbm+Gz+dTp9PJmDebTctqtapSqfQjmYFer2cSQCV5rtfrNvg3WAaB1+ulT+GQwmBkOIjIzmQyJpf/SI98RhbJIQwGA5NKrVQq1u+Ox6Nthi5ecGLxeNz8KZfL1swwPmML/nEIzJF4GlWYm4cwrNVqtsjzPCWTSVsYeQryfwJCLnrhbnFihULB5GI014B7CDMCBp+S+IrF9A1Ktp+p2rDNqgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image4\"\n        title=\"image4\"\n        src=\"/static/ac4651bba63717b0a97fcd9efbf8248d/37523/image4.png\"\n        srcset=\"/static/ac4651bba63717b0a97fcd9efbf8248d/e9ff0/image4.png 180w,\n/static/ac4651bba63717b0a97fcd9efbf8248d/f21e7/image4.png 360w,\n/static/ac4651bba63717b0a97fcd9efbf8248d/37523/image4.png 720w,\n/static/ac4651bba63717b0a97fcd9efbf8248d/612f7/image4.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<br></p>\n<p>그렇다면 누구를 주인으로 지정해주어야 할까?</p>\n<p>비즈니스 중요성과 관계없이 무조건 FK가 있는 테이블 쪽 ( <strong>N:1에서 N인 곳</strong> ) 을 주인으로 정해야 한다.</p>\n<br>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.222222222222214%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkklEQVQoz22Sx4oDQQxE+/+/x8YHY3DEBmOcc84551jLEztmDysQ3dMjlUoluc/nI+zxeJj3ej3l83lls1lNp1O1Wi3V63U1m00Nh0ONx2PVajWlUillMhnzSCSi0Wik5/Mpp1/jATCSASsUCppMJgZ0PB7ND4eD5vO5FouFSqWS5RSLRSMwGAzU7/flLpeLrtergVWrVa1WKwt8vV5WaLPZiBg6wYmlE4rRAaw82263clQjgXbC4bCi0aj5crnUbrczhhS53W4Ght/vd7Xb7W98LBazEzkcbWBU2u/3Rj2dTpsu5XLZ9AKUDvjmjm65XE7JZFLBYFCBQMD+Ucx1Oh3Tg5NWG42GMfhrfNOmd57PZ7u/329zb7CYox2YcaJBt9s1cdHndDrZMP4zOgJ4vV5bLHfiHWAYIjNZ9AiFQtYy04axNxASSKQw75VKxdYH/ZAAWRxTBJSffr9fPp9PiUTiu1usEayJgQ06wRpACsfjcdOdDTFAqKMHj4jM5LyBwATQvxp5BlOWHnnYzdlsZiv2A+kw4JaHCyP3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image5\"\n        title=\"image5\"\n        src=\"/static/687624527312986690a0e8ee411b42aa/37523/image5.png\"\n        srcset=\"/static/687624527312986690a0e8ee411b42aa/e9ff0/image5.png 180w,\n/static/687624527312986690a0e8ee411b42aa/f21e7/image5.png 360w,\n/static/687624527312986690a0e8ee411b42aa/37523/image5.png 720w,\n/static/687624527312986690a0e8ee411b42aa/612f7/image5.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<br></p>\n<h3 id=\"양방향-매핑-시-가장-많이-하는-실수\" style=\"position:relative;\"><a href=\"#%EC%96%91%EB%B0%A9%ED%96%A5-%EB%A7%A4%ED%95%91-%EC%8B%9C-%EA%B0%80%EC%9E%A5-%EB%A7%8E%EC%9D%B4-%ED%95%98%EB%8A%94-%EC%8B%A4%EC%88%98\" aria-label=\"양방향 매핑 시 가장 많이 하는 실수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>양방향 매핑 시 가장 많이 하는 실수</h3>\n<ol>\n<li>\n<p>연관관계의 주인이 아닌 쪽에서 수정/저장을 하는 경우</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setUserName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"member1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Team</span> team <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nteam<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TeamA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nteam<span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위와 같이 코드를 실행하면 member 테이블이 가지고 있는 FK인 team_id에 데이터가 저장되지 않는다. 앞서 말했듯, 연관관계의 주인이 아닌 쪽은 ‘Read-only’이기 때문이다.</p>\n<p>그렇기 때문에 아래와 같이 연관관계의 주인인 Member 클래스에서 team을 추가해주어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Team</span> team <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nteam<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TeamA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//team.getMembers().add(member);</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setUserName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"member1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// team_id 로 매핑됨. </span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ol>\n<br>\n<ol start=\"2\">\n<li>\n<p>연관관계의 주인이 아닌 쪽에서 연관관계를 매핑하지 않는 경우</p>\n<p>아니 주인이 아닌 쪽에서는 연관관계 매핑을 하지말라며? 뭔 소리야? 라고 생각 할 수 있다.</p>\n<p>하지만 정확히는 위와 같이 연관관계의 주인이 아닌 쪽에서 사용해서 수정/저장을 하지 말라는 거지 이렇게 주인이 아닌 쪽에서 연관관계 매핑을 쓰지 말라는 뜻이 아니다.</p>\n<p>오히려 2가지 이유로 양쪽 클래스 모두에 값을 설정\b해주어야 한다. 즉 Team에서도 아래와 같이 add Member를 해주어야 한다는 뜻이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">team<span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>(1) 객체지향으로 생각해보면 team에도 add member를 해주고,member에도 team을 설정해주는게 맞다.</p>\n</li>\n<li>\n<p>(2) <strong>JPA에서는 영속성 컨텍스트의 1차캐시에서 먼저 값을 조회해오기 때문에 발생하는 이슈</strong>가 있다.\n즉 DB가 아닌 1차캐시에서 데이터를 가져오게 되면 사실 상 순수 객체 상태기 때문에 양방향 매핑이 필요하다. 아래 코드를 살펴보자.\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">  <span class=\"token class-name\">Team</span> team <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  team<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TeamA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  em<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  member<span class=\"token punctuation\">.</span><span class=\"token function\">setUserName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"member1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  member<span class=\"token punctuation\">.</span><span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// team_id 로 매핑됨. </span>\n  em<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">//team.getMembers().add(member); 이걸 주석해제 해주면 1차캐시 문제를 해결 가능</span>\n  <span class=\"token comment\">// em.flush();</span>\n  <span class=\"token comment\">// em.clear();   </span>\n\n  <span class=\"token comment\">/* 위에서 저장된 team을 DB가 아닌 영속성 컨텍스트 내의 1차캐시로부터 불러온다. (flush, clear가 안되었다면)\n  즉 반환되는 값은 순수 객체상태라고 보면 되고 따라서 team 객체의 member list는 비어 있을 것이다. \n  셋팅해준 적이 없으니깐. */</span>\n  <span class=\"token class-name\">Team</span> findTeam <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Team</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> team<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">Lis</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">></span></span> members <span class=\"token operator\">=</span> findTeam<span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span> m <span class=\"token operator\">:</span> members<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"m=\"</span><span class=\"token operator\">+</span>m<span class=\"token punctuation\">.</span><span class=\"token function\">getUserName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//아무것도 안찍힘. </span>\n  <span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>위 코드에서 Flush, clear를 해주지 않았다면 영속성 컨텍스트의 1차캐시로부터 team 객체를 가져오게 될 것이기 때문에 사실상 순수 team객체를 가지고 오는 것과 같고, team객체에는 member list에 대해서 설정해준 것이 아무것도 없기 때문에 null값을 반환하게 될 것이다.</p>\n<p>따라서 이와 같은 문제 해결을 위해 주석을 해제하여 객체 간 서로 참조할 수 있게 아래와 같이 매핑해주어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">team<span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그리고 이를 쉽게 해주기 위해 **‘양방향 편의 메소드’**를 설정해주면 좋다. 연관관계의 주인 쪽(Member)에 아래와 같이 setTeam메소드 대신 changeTeam으로 변경해주고 Member.changeTeam(team)시 Member와 Team쪽에서 모두 값이 매핑되도록 설정해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">changeTeam</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>team <span class=\"token operator\">=</span> team<span class=\"token punctuation\">;</span>\n  team<span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//양방향 매핑. </span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>반대로 연관관계의 주인이 아닌 Team쪽에서 양방향 매핑되도록 편의 메소드 설정을 해줘도 된다.\n그러나 <strong>반드시 Member 또는 Team 둘 중 한 곳에서만</strong> 편의 메소드를 설정해야 함에 주의하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">addMember</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span> member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  members<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  member<span class=\"token punctuation\">.</span><span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>(3) 양방향 매핑시 발생하는 무한 Loop</p>\n<p>toString이나 json 생성 라이브러리 사용 시에 순환 참조 문제가 발생한다.  즉 Member가 Team을 참조하고 Team안에는 또 Member가 있고 다시 그 Member안에 Team 참조…무한 반복되는 문제. toString은 쓰지 않는 것을 추천하고 json으로 controller에서 내려줄 때는 entity로 절대 반환하지 말고 DTO를 통해 response 주도록 해야 한다.</p>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>오늘의 간단 정리</p>\n<ul>\n<li>단방향 매핑만으로도 연관관계 매핑은 끝난다.</li>\n<li>양방향은 필요하면 추가하면 되고 편의메소드를 쓰면 됨.</li>\n<li>연관관계의 주인은 FK가 있는 곳이 기준이다.</li>\n</ul>\n<hr>\n<p>참고자료</p>\n<ul>\n<li><a href=\"https://www.inflearn.com/course/ORM-JPA-Basic\">https://www.inflearn.com/course/ORM-JPA-Basic</a></li>\n</ul>\n<p>​</p>","excerpt":"JPA 연관관계 매핑을 배우기에 앞서, 객체와 테이블의 연관관계를 맺는 방법이 다르다는 것을 이해해야 한다.\nJPA 1. 에서 언급했듯이, 객체는 참조를 통해, 테이블은 FK를 통한 조인으로 연관관계를 맺는다. 회원과 팀이 다대일 관계일 때 객체를 테이블에 맞추어 모델링 한다면 아래와 같을 것이다.  그리고 이렇게 Entity 상에서 이렇게 매핑을 하게 되면 서로 연관된 데이터를 가져오고 싶을 때 이렇게 Id를 통해서만 가져올 수 있게 된다. 그리고 이것은 객체지향스럽지 않은 방식이다.\nJPA에서는(ORM에선) 이를 어떻게 모델링 할 수 있을까?\nJPA에서는 단방향, 양방향 연관관계를 통해 객체지향적으로 프로그래밍이 가능하도록 해준다. 1. 단방향 연관관계  Entity 클래스에서 참고하고자 하는 다른 Entity 클래스의 참조형을 멤버변수로 선언하는데,\n이 때 참조형으로 생성하는 Entity는 FK를 가지고 있지 않은 쪽 ( ‘Many’ 인 쪽 ) 이다.\n즉 Team과 Membe…","frontmatter":{"date":"March 12, 2022","title":"[JPA] 5. 연관관계 매핑 (feat. 연관관계의 주인)","categories":"Spring","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/jpa5/"}},"next":{"id":"d55f696e-f426-568d-a0cf-2ec92a0ff11c","html":"<p>JPA의 내부동작, 즉 영속성 컨텍스트의 정의, 장점, 라이프사이클 등에 대해서\b 이전 글을 통해 알아 봤다면,\n이제 Entity 매핑을 실제로 어떻게 하는 지를 알아보자.</p>\n<h2 id=\"1-객체와-테이블-맵핑--entity-table-\" style=\"position:relative;\"><a href=\"#1-%EA%B0%9D%EC%B2%B4%EC%99%80-%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%A7%B5%ED%95%91--entity-table-\" aria-label=\"1 객체와 테이블 맵핑  entity table  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 객체와 테이블 맵핑 ( @Entity, @Table )</h2>\n<p>@Entity가 붙은 클래스는 JPA가 관리하게 된다.</p>\n<ul>\n<li>\n<p>Entity 작성 시 주의사항</p>\n<ul>\n<li>기본 생성자는 필수이다.</li>\n<li>final, enum, interface, inner 클래스 사용 X</li>\n<li>저장할 필드에 final 사용 X</li>\n</ul>\n</li>\n<li>\n<p>@Table은 엔티티와 맵핑할 테이블 지정 가능</p>\n</li>\n</ul>\n<h2 id=\"2-db-스키마-자동-생성\" style=\"position:relative;\"><a href=\"#2-db-%EC%8A%A4%ED%82%A4%EB%A7%88-%EC%9E%90%EB%8F%99-%EC%83%9D%EC%84%B1\" aria-label=\"2 db 스키마 자동 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. DB 스키마 자동 생성</h2>\n<ul>\n<li>\n<p>JPA에서는 DDL을 앱 실행 시점에 자동 생성해준다. ( 운영 환경에서는 사용하면 안됨 )</p>\n<p>: JPA가 테이블 중심이 아닌 객체 중심임을 보여준다.</p>\n</li>\n<li>\n<p>persistence.xml에서 아래와 같이 옵션이 설정되어 있어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>hibernate.hbm2ddl.auto<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>create<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n</li>\n</ul>\n<p>여기서 value값에 옵션을 지정해주는데 옵션의 종류는 아래와 같다.</p>\n<ul>\n<li>create : 기존테이블 삭제 후 다시 생성(DROP + CREATE)</li>\n<li>create-drop : create과 같으나 종료시전에 테이블 DROP</li>\n<li>update : 변경분만 반영</li>\n<li>validate : 엔티티와 테이블이 정상 매핑되었는지만 확인</li>\n<li>none : 사용하지 않음을 의미</li>\n</ul>\n<p>옵션에 따라 어플리케이션 실행 시 위와 같이 DDL이 생성되기 때문에 환경에 따라 철저히 옵션을 구분해서 아래와 같이 사용해야 한다.</p>\n<p>​</p>\n<ul>\n<li>운영장비:  create, create-drop, update사용하면 안되고 validate  / none 사용</li>\n<li>개발 초기:  create / update</li>\n<li>어느정도 개발이 진행되었다면 : update / validate</li>\n</ul>\n<h2 id=\"3-필드와-컬럼-맵핑--column\" style=\"position:relative;\"><a href=\"#3-%ED%95%84%EB%93%9C%EC%99%80-%EC%BB%AC%EB%9F%BC-%EB%A7%B5%ED%95%91--column\" aria-label=\"3 필드와 컬럼 맵핑  column permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 필드와 컬럼 맵핑 (@ Column)</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Id</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> memberName<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> age<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Enumerated</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">EnumType</span><span class=\"token punctuation\">.</span>STRING<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">RoleType</span> roleType<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//varchar로 생성됨. 정해진 status값 같은 데 쓰면 됨</span>\n    <span class=\"token annotation punctuation\">@Lob</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> description<span class=\"token punctuation\">;</span> <span class=\"token comment\">//문자면 CLOB으로, 나머지는 BLOB으로 맵핑 됨.  </span>\n    <span class=\"token annotation punctuation\">@Transient</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> temp<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// DDL 생성하지 않고 애플리케이션 내에서만 사용하게 됨 </span></code></pre></div>\n<h3 id=\"1-column\" style=\"position:relative;\"><a href=\"#1-column\" aria-label=\"1 column permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) @Column</h3>\n<ul>\n<li>nullable : false,true ( DDL에서 not null constraint 걸어 주고 validation도 지원 )</li>\n<li>length : String에서 길이 제한</li>\n<li>precision : BigDecimal처럼 엄청 큰 숫자를 사용하는 컬럼의 소수점을 지정해줄 때 사용</li>\n</ul>\n<h3 id=\"2-enumtype--쓸-때-주의-사항\" style=\"position:relative;\"><a href=\"#2-enumtype--%EC%93%B8-%EB%95%8C-%EC%A3%BC%EC%9D%98-%EC%82%AC%ED%95%AD\" aria-label=\"2 enumtype  쓸 때 주의 사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) EnumType  쓸 때 주의 사항</h3>\n<p>​기본이 ORDINAL이고 STRING으로 지정 가능한데 반드시 STRING으로 써야 한다.</p>\n<p>ORDINAL은 enum의 순서 정보를, STRING은 enum의 이름을 DB에 저장하게 되는데,</p>\n<p>ORDINAL을 쓰면 안되는 이유는 enum에서 값이 추가 됐을 경우에 DB에 기존에 있던 데이터와 앱 상에서 업데이트 된 enum의 순서에 대한 정보가 꼬이게 되어 버그 발생할 수 있기 때문이다.</p>\n<h3 id=\"3-기본-키-맵핑-전략\" style=\"position:relative;\"><a href=\"#3-%EA%B8%B0%EB%B3%B8-%ED%82%A4-%EB%A7%B5%ED%95%91-%EC%A0%84%EB%9E%B5\" aria-label=\"3 기본 키 맵핑 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) 기본 키 맵핑 전략</h3>\n<p>@Id</p>\n<p>@GeneratedValue(strategy = GenerationType.{IDENTITY, TABLE, SEQUENCE, AUTO}</p>\n<p>-> id에 대한 생성 전략은 크게 identity, table, sequence 3가지 이며 auto로 설정할 경우 properties파일에서 설정한 jpa의 dialect에 따라서 알아서 설정을 해준다. mysql은 IDENTITY, oracle은 SEQUENCE 이런 식으로.</p>\n<ul>\n<li>\n<ol>\n<li>IDENTITY 전략을 쓰면 커밋 시점이 아닌 em.persist() 시점에 즉시 INSERT 문을 실행하고 DB로부터 식별자를 리턴 받아온다. 그래서 IDENTITY 전략 쓰면 영속성 컨텍스트의 장점 중 하나인 ‘지연 쓰기’ 기능 사용할 수 없으나 성능에 큰 영향은 없다.</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>SEQUENCE 전략을 쓰면 em.persist() 시점에 DB의 시퀀스로부터 next val을 받아와서 영속성 컨텍스트의 1차 캐시에 id값을 저장하게 되지만 INSERT문은 커밋 시점에 한 꺼번에 실행가능하다. 하지만 이 경우 persist마다 call next val을 해야 하는 성능 상의 문제가 있는데, allocationSize 설정을 통해 해결할 수 있다.</li>\n</ol>\n</li>\n</ul>\n<hr>\n<p>참고자료</p>\n<ul>\n<li><a href=\"https://www.inflearn.com/course/ORM-JPA-Basic\">https://www.inflearn.com/course/ORM-JPA-Basic</a></li>\n</ul>","frontmatter":{"date":"March 08, 2022","title":"[JPA] 4. 엔티티(Entity) 매핑 기초","categories":"Spring","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/jpa4/"}},"prev":{"id":"82e6428f-f8dc-5910-93fa-96947ef11565","html":"<p>asdfasdf\nasdfads\nasdfasdfasdfasdf</p>","frontmatter":{"date":"March 15, 2022","title":"[JPA] 8. JPA프록시와 지연로딩(Lazy Loading)과 즉시로딩(Eager Loading)","categories":"Spring","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/jpa8/"}},"site":{"siteMetadata":{"siteUrl":"https://steadyandslow.com","comments":{"utterances":{"repo":"jjunyong/jjunyong.github.io"}}}}},"pageContext":{"slug":"/jpa5/","nextSlug":"/jpa4/","prevSlug":"/jpa8/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}