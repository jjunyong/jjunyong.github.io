{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/Linux","result":{"pageContext":{"currentCategory":"Linux","categories":["All","Troubleshoot","Java/Kotlin","영어","Linux","DevOps","클라우드","독서","WEB","회고","Error","Data","AWS","Spring","디자인패턴"],"edges":[{"node":{"id":"62e2776b-878c-50ba-8ec2-52796b363310","excerpt":"1. root 비번 재설정 VM 재기동 ( ctrl-alt-delete ) rescue console ‘e’(edit) 로 진입하여 linux … 행에  추가 Ctrl-x로 저장하면 자동으로 레스큐 콘솔로 재부팅 된다. iui ]o[o[]]i][ ][i]i[][i] l[]o[]o] kkkk echo ‘anypass’ | passwd —stdin root 재부팅 시 파일 시스템의 SELinux 컨텍j스j트를 자동으로 재라벨링하도록 한다. touch /.autorelabel |  ``` 2. 서버 네트웍 설정 x nmtui 명령을 통해 진입하는 콘솔에서 hostname, ip, gateway, dns server 등에 대한 설정 가능 3. 서버 리포지토리 관리 dnf repository 추가 4. SELinux SELinux의 http에 추가된 포트 확인 및 포트 추가 방화벽에 위에서 추가된 82번 port를 오픈하기 위해 추가 httpd 재시작 및 적용 5.논리 볼륨 크기 조정 -r…","fields":{"slug":"/rhcsa/"},"frontmatter":{"categories":"Linux DevOps","title":"RHCSA","date":"March 25, 2024"}},"next":{"fields":{"slug":"/network-practice10/"}},"previous":{"fields":{"slug":"/spa1/"}}},{"node":{"id":"198556a6-a105-5002-b5c9-2be18541f705","excerpt":"전체적인 쿠버네티스 네트웍 구조는 Service를 통해 pod를 노출시키되, service는 L4영역까지만 담당하고,\nL7의 역할을 하는 ingress를 Loadbalancer type service와 연결시켜서 사용하게 되는 구조이다. 멀티 노드 클러스터를 외부에 노출하기 위해서 Loadbalancer를 꼭 써야 하는 것은 아니다. 물론 그렇게 할 수도 있지만,\n특정 워커 노드들에 ingressgateway를 고정으로 박아두고, nodePort로 오픈한 다음, 앞 단에 로드 밸런서를 두고 해당 node의 ip : port로 로드밸런싱되도록 설정할 수도 있다. rolling update 배포 모니터링 : watch -n 0.1 옵션 사용으로 실시간 확인 가능 롤백 k8s 네트웍 용어 NAT : 내부망을 위한 ip 주소로 변환 SNAT : 패킷이 내부에서 외부로 나갈 때 Source ip주소를 고정(public) ip로 변환 DNAT : 패킷이 외부에서 내부로 들어올 때 Destin…","fields":{"slug":"/network-practice10/"},"frontmatter":{"categories":"Linux DevOps","title":"쿠버네티스 네트웍 내부구조","date":"March 05, 2024"}},"next":{"fields":{"slug":"/network-practice9/"}},"previous":{"fields":{"slug":"/rhcsa/"}}},{"node":{"id":"62d2a112-6dad-551a-b4e4-7650a4035595","excerpt":"super user 권한 없이 docker 사용하기 docker에서 컨테이너 생성하고 내부로 들어가기 컨테이너란? 컨테이너는 독립된 리눅스 환경이다. 컨테이너는 단일 프로세스이다.\n Docker 구조  부모 프로세스가 1번인 daemon 프로세스의 형태로 dockerd는 구동된다. docker CLI 명령은 dockerd에 전달된다. 전달하는 방식은 /var/run/docker.sock containerd가 container runtime이며 /run/containerd/containerd.sock 을 통해서 docker\bd와 통신한다. docker 컨테이너 내부에서 CLI명령을 사용하고자 하면 전체 컨테이너에 대한 정보를 dockerd를 통해서 알아내야 하기 때문에 호스트의 /var/run/docker.sock를 도커 컨테이너 내에서 참조할 수 있도록 마운트되어야 한다. dockerd, docker CLI 프로세스는 아래와 같이 tmpfs 파일 시스템 즉, 메모리에 올라간 doc…","fields":{"slug":"/network-practice9/"},"frontmatter":{"categories":"Linux 클라우드","title":"Docker 네트워크 구조","date":"February 27, 2024"}},"next":{"fields":{"slug":"/network-practice8/"}},"previous":{"fields":{"slug":"/network-practice10/"}}},{"node":{"id":"cbb0e8f2-511e-5809-be88-755753683ae4","excerpt":"네트워크 장비와 구조  라우터 L3: IP주소 기반으로 다른 네트워크와의 연결 장비\n 스위치 L2: 여러 컴퓨터 통신연결장비 (오류검사, 빠른 속도, 멀티포트 브릿지 )\n 브릿지 L2: 컴퓨터와 컴퓨터간의 통신연결 장비로 허브보다 스마트하다. 브로드캐스트가 아니라 목적지 pc에 전달해준다.\n 허브 L2: 단순 브로드 캐스트를 하는 통신연결 장비 (‘깡통허브’)이며 실제로는 헙 잘 안쓰고 스위치를 많이 쓴다.\n IPv4 주소 32bit로 2^32승(약 42억개)의 ip 수용 가능 본래는 ip주소는 모든 host에 하나씩 할당 해주는 것이 목적이었으나 ip주소가 부족해짐. 그런데 어떻게 할당해주는가? 클래스 단위로 할당한다. A클래스는 8bit, B클래스는 16bit, C클래스는 24bit을 네트웍 주소로 사용하고, 나머지 bit을 host주소에 할당해준다. 그러나 클래스 방식으로 ip를 할당하는 방식은 A~C클래스 사이에서 애매한 부분이 있어 비효율이 발생하므로 이제는 CIDR 방식…","fields":{"slug":"/network-practice8/"},"frontmatter":{"categories":"Linux","title":"IPv4 네트워크 기본","date":"February 21, 2024"}},"next":{"fields":{"slug":"/network-practice7/"}},"previous":{"fields":{"slug":"/network-practice9/"}}},{"node":{"id":"016d5757-9480-5b12-938b-abb75ebf0106","excerpt":"리눅스 VFS systemcall 중 가장 많이 쓰이는 것은 open, read, write이다. 리눅스에서는 모든 자원을 VFS를 통해 파일처럼 쓰고 읽을 수 있게 되어 있기 떄문이다.\n\n\n file들이 반드시 ssd,hdd에 저장된게 아니라 메모리에 연결된 것들도 있고, 네트웍도 파일이다. df -h 했을 때 Filesystem이 tmpfs로 나오는 건 메모리에 연결된 것이며, /run 디렉토리가 이에 해당함을 확인할 수 있다. /proc 하위에 있는 파일들도 procfs라는 Filesystem을 사용하며 이는 커널이 메모리에 동적으로 데이터를 저장한다. 리눅스 네트워크 도구 hping3 명령어 hping3의 옵션을 사용하여 다양한 테스트 가능 fast faster flood : 보낼 수 있는 만큼 응답기다리지 않고 많이 보내기 (ddos공격 시 활용 가능) iptables 명령어 blacklist 관리 가능 3번째 단계에서 hping3 패킷을 보낼 떄 규칙이 설정되어 있으면 …","fields":{"slug":"/network-practice7/"},"frontmatter":{"categories":"Linux","title":"리눅스VFS와 네트워크와 네트웍 도구","date":"February 07, 2024"}},"next":{"fields":{"slug":"/network-practice6/"}},"previous":{"fields":{"slug":"/network-practice8/"}}},{"node":{"id":"2c244566-102b-527a-a252-0675250dd9af","excerpt":"MSS란? L4계층의 개념이며 Maximum segment size의 약자로서 TCP에서 전송할 수 있는 사용자 payload 크기 TCP header를 제외한 payload만의 크기이다. 그리고 payload는 각 네트웍 계층에 따라 상대적인 개념이다. (ex. L4에서는 http 헤더가 payload. L3에서는 tcp헤더도 payload)\n\n\n 그리고 전 layer에 걸쳐서 ethernet frame을 포함하여 패킷은 sk_buff 구조체로 리눅스 커널 내부에서는 관리된다. MSS는 말 그대로 최대치를 의미하며 이것 보다 큰 데이터는 fragment로 조각을 내서 전송한다. MTU란?  L3계층의 개념이며 Maximum Transmission Unit의 약자로서 네트욱에서 전송할 수 있는 최대 패킷 크기이다. 라우터 마다 이 설정이 다를 수 있다. 예컨대 내 PC는 1000byte가 MTU여서 1000byte를 보냈더라도 중간에 어떤 라우터의 MTU가 700이면 패킷을 쪼개서…","fields":{"slug":"/network-practice6/"},"frontmatter":{"categories":"Linux","title":"MTU와 MSS 이해와 실습","date":"January 31, 2024"}},"next":{"fields":{"slug":"/network-practice5/"}},"previous":{"fields":{"slug":"/network-practice7/"}}},{"node":{"id":"fd61eeb0-5e55-5f3a-9467-0f0c5a2075e9","excerpt":"네트워크 소켓 메모리 공간을 결정하는 커널 설정 kernel parameter를 runtime에 설정할 수 있게 해주는 sysctl 명령 활용 \n net.core.*는 tcp,icmp등 프로토콜 관계없이 모든 통신과 관련한 설정 net.ipv4.tcp.* 는 tcp관련 소켓 메모리 설정 값이다. 이들 설정값의 단위는 다 byte단위가 아니라 어떤건 page단위(보통 4kb), 어떤 건 byte단위이다.  첫 번째 그림에서 보면 tcp 메모리 관련해서 하나의 값만 있는게 아니라 3개의 값이 존재한다. 이것은 min, pressure, max 수치이다. 커널을 pressure모드로 설정할 수가 있는데, 커널 내부적으로 tcp에서 메모리를 사용할 때 메모리 할당 전에 pressure모드인지 아닌지를 체크한다. pressure mode이면 pressure수치를 사용한다. 커널이 pressure모드이면 리소스 활용을 최소화하고 안 쓰는 메모리 공간을 여유 메모리공간으로 할당하는 등 리소스를…","fields":{"slug":"/network-practice5/"},"frontmatter":{"categories":"Linux","title":"Write, Read 소켓 버퍼 커널 설정","date":"January 31, 2024"}},"next":{"fields":{"slug":"/network-practice4/"}},"previous":{"fields":{"slug":"/network-practice6/"}}},{"node":{"id":"4671719b-df0c-5bf2-a894-d46d7933e872","excerpt":"네트워크 I/O 과정 ESTABLISHED 그 이후.. Client와 Server는 서로 데이터 패킷을 주고 받게 된다.  송신 측에서 socker 버퍼에 패킷을 집어넣는다. 패킷이 목적지에 도착하면 목적지인 수신 측 컴퓨터는 하드웨어 디바이스들이 직접 접근할 수 있는 메모리의 DMA 영역에 패킷을 저장한 이후에, CPU에 irq(interrupt 요청)를 보내서 패킷이 도착함을 알린다. hard irq, soft irq 과정 ( hi, si ) hard irq에서는 간단한 작업만을 하게 된다. interrupt를 통해 CPU를 깨우고, ISR이 해당 인터럽트에 대한 처리를 하게 함과 동시에 network stack에 event를 발생시켜 수신된 패킷이 있음을 알린다. (+flag set 정도) soft irq는 네트웍 스택에 의해 스케줄링 되며 스케줄에 따라 CPU가 soft interrupt handler를 실행시켜 수신된 패킷을 처리한다. 수신한 패킷 파싱, 헤더 분석, 검증…","fields":{"slug":"/network-practice4/"},"frontmatter":{"categories":"Linux","title":"리눅스 네트워크 I/O 분석","date":"January 25, 2024"}},"next":{"fields":{"slug":"/network-practice3/"}},"previous":{"fields":{"slug":"/network-practice5/"}}},{"node":{"id":"667f083c-01cb-58d6-99fe-4390e99377cf","excerpt":"TCP란? Transmission Control Protocol L4 계층 통신 TCP의 가장 중요한 키워드는 “커넥션”이다. 통신 전에 커넥션을 맺고 통신이 끝나면 커넥션을 해지한다. HTTP 통신을 할 때도 TCP/IP 통신을 기반으로 한다. TCP 통신의 과정 연결 : 3 way handshaking\n 데이터가 없는 Ethernet header, IP header, TCP Header로만 이루어진 SYN 패킷을 보낸다. 이 떄 TCP Header에 SYN으로 표시되어 있다. 그 이후의 SYN,ACK 와 ACK 패킷도 마찬가지이다. 데이터 통신\n HTTP 통신이라고 가정하면, HTTP 헤더/바디를 포함한 message 데이터가 추가된 데이터 패킷을 주고 받는다. 해지 : 4 way handshaking\n 해지도 연결과 마찬가지로 데이터가 없는 FIN, ACK 패킷을 주고받음으로써 연결을 해지한다. L7의 프로토콜에 따라 다르지만 데이터 통신이 오고가는 과정에서 계속 3 way …","fields":{"slug":"/network-practice3/"},"frontmatter":{"categories":"Linux","title":"TCP/IP 통신과정 추적","date":"January 23, 2024"}},"next":{"fields":{"slug":"/network-practice2/"}},"previous":{"fields":{"slug":"/network-practice4/"}}},{"node":{"id":"61b0e906-b9a8-5a86-baeb-f9f04aa69b87","excerpt":"네트워크 통신과정 : 라우팅 추적 traceroute 중간에 보이는 * 은 보안, 설정, 부하 등으로 인해 응답이 없었던 라우터이다. 처음에 LAN의 gateway를 타고 나가서 router들을 거쳐 목적 서버로 도착하게 된다. 동일 hop에 여러개의 ip가 나타나는 것은 여러 개의 경로가 있을 수 있음을 의미한다. ICMP란? Internet Control Message Protocol L3 통신이다. (TCP통신이 아님에 유의) 라우터를 포함한 네트웍 장치가 통신 체크 용도로 사용된다. ping tshark 설치하기 -f, -Y옵션은 패킷 filtering을 위해 사용되며 -f는 protocol을 필터링하고, -Y 뒤에는 표현식을 적어주어 필터링한다. ARP란? Address Resolution Protocol L2(데이터링크 계층) 통신 IP주소를 MAC주소에 매핑하기 위하여 사용된다. 최종 목적지의 MAC주소를 이더넷 프레임에 포함하지는 않는다. (목적지가 LAN내라면 그럴…","fields":{"slug":"/network-practice2/"},"frontmatter":{"categories":"Linux","title":"라우팅 추적(ICMP)과 ARP","date":"January 21, 2024"}},"next":{"fields":{"slug":"/network-practice1/"}},"previous":{"fields":{"slug":"/network-practice3/"}}},{"node":{"id":"3a2ba688-9f6b-5255-8014-cb170f8bfe48","excerpt":"리눅스의 네트워크 처리  리눅스 OS는 네트워크 카드를 포함한 하드웨어를 관리하는 역할을 한다.\nOS 위에서 실행되는 application이 하드웨어(여기선 네트웍) 사용하기 위해서는 Linux kernel에 systemcall을 보내야 하고, 가장 많이 open, read, write와 같은 systemcall이 사용된다.\n\n\n네트웍 자원을 사용할 때는 open대신 socket이라는 systemcall을 사용하게 되며 read 명령은 receive, write명령은 send의 역할을 하게 된다.\n이외에도 네트워크 처리함수들은 Linux kernel에 내장되어 있다.\n\n\nL2~L4의 처리를 리눅스의 네트웍 함수들을 사용하여 소프트웨어적으로 처리할 수도 있지만 하드웨어에 내장된 기능을 통해 ‘하드웨어 오프로드’로 더 빨리 처리할수도 있다.\n\nEthernet frame에서 붙는 mac주소의 destination은 내부망(LAN)에서는 실제 목적지 컴퓨터의 mac주소가 맞지만, WAN에…","fields":{"slug":"/network-practice1/"},"frontmatter":{"categories":"Linux","title":"리눅스 네트워크 처리와 http통신","date":"January 19, 2024"}},"next":{"fields":{"slug":"/reallinux-seminar/"}},"previous":{"fields":{"slug":"/network-practice2/"}}},{"node":{"id":"ec0819e9-a324-5eca-9143-f54c4eaf286b","excerpt":"문제란 무엇인가? 문제란 목표와 현 상황의 차이(Gap)이다. 따라서 단순히 에러 메시지가 어떻다에서 그치지 않고 목표를 정확하게 잘 정의하는 것이 중요하다. 문제 해결의 다양한 접근 방법 1 : “문제의 현상과 원인은 다르다” 예를 들어 보자. 문제의 현상 : 파일 생성 오류 파일 생성 오류가 나는 것은 root cause가 아니라 현상이다. 따라서 이에 대한 원인을 하나씩 찾아나가는 것이 중요하다. 문제 해결의 다양한 접근 방법 2 : “잘게 쪼개고 구체화하라” 절차, 단계, 열거, 관찰, 점검을 통해 문제를 해결한다. 리눅스 / 네트웍이 어떻게 원래 돌아가는 지 알아야 절차와 단계, 열거를 할 수 있다. 이게 가능하기 위해서는 2~3 depth까지는 현상 뿐만이 아니라 원리(왜 되는지?) 에 대해서 알아야 한다. 문제 해결의 다양한 접근 방법 3 : “연역적 접근 vs 귀납적 접근”  연역적 접근 방식 만으로는 변수와 예외가 너무 많기에 해결이 안될 수도 있다. 따라서 경험을…","fields":{"slug":"/reallinux-seminar/"},"frontmatter":{"categories":"DevOps Linux","title":"[기술 세미나] 리눅스 패키지 문제해결 사례 핵심분석","date":"December 15, 2023"}},"next":{"fields":{"slug":"/read-center-church10/"}},"previous":{"fields":{"slug":"/network-practice1/"}}},{"node":{"id":"8b549f2c-eb53-5f8d-a1fd-140214660f05","excerpt":"1. 인터넷 DNS A레코드에 대하여 Client - Server 구조 public ip, private ip, NAT 개념 2. Apache 웹 서버 웹 브라우저와 웹 서버 apache 설치, elinks 활용 apache conf 파일에서 log, document root 설정 3. 원격제어 SSH SSH client가 설치된 컴퓨터에서 SSH server가 설치된 컴퓨터를 원격제어 할 수 있다. 이것은 웹브라우저와 웹서버의 관계와 매우 유사하다. SSH 서버 설치하기 openssh-server 설치 sshd가 실행되면 정상이다. 4. 포트(Port) port는 서버의 ‘문’ 과 같은 역할이다. well-known port(0~1024): 22, 80, 443 등 ssh, http도 다른 port로 접속되게 할 수 있다. 포트포워딩 : 라우터의 설정에서 private network의  포트 포워딩 할 수 있다. 5. 도메인 hosts 파일 도메인 구입 서브 도메인 DNS 동작 …","fields":{"slug":"/mysql-dbeaver-dump/linux-w5/"},"frontmatter":{"categories":"Linux","title":"[리눅스 스터디] 5. 인터넷, 네트워크, 도메인","date":"July 24, 2023"}},"next":{"fields":{"slug":"/error-docker-overlay/"}},"previous":{"fields":{"slug":"/read-center-church0/"}}},{"node":{"id":"ac135b72-3f2e-5478-b606-5285ff7d22b1","excerpt":"다중 사용자 id : 를 쉘에서 입력하면 uid, gid 등에 대한 정보를 알 수 있다. who :  명령은 현재 서버에 누가 접속 했는 지를 확인 할 수 있다. 관리자와 일반 사용자 관리자는 super user의 권한을 갖고, 일반 사용자가 임시로 super권한을 쓰기 위해서는 ‘sudo’ 명령을 쓰게 된다 sudo passwd -u root root 사용자 unlock하기 sudo passwd -l root root 사용자 lock하기 사용자의 추가 : 홈 디렉토리의 생성과 함께 ( -m 옵션 ) tester라는 계정을 생성함\n : 비밀번호 설정 권한 권한을 지정한다는 것은 리눅스에서는 ‘파일과 디렉토리’에 대한 읽기/쓰기/실행 하는 권한을 말한다. 파일의 권한 chmod : 권한 변경하기 파일/디렉토리의 access mode를 변경하기 위해서는 ‘chmod’라는 명령어를 사용한다. chmod {u/g/o/a}{+/-}{r/w/x} 로 해당 명령을 쓸 수 있고 숫자로도 chmo…","fields":{"slug":"/linux-w4/"},"frontmatter":{"categories":"Linux","title":"[리눅스 스터디] 4. 사용자 & 권한 & 그룹","date":"July 19, 2023"}},"next":{"fields":{"slug":"/on-premise8/"}},"previous":{"fields":{"slug":"/error-docker-overlay/"}}},{"node":{"id":"840bfffc-342f-5f6a-8093-3eca088a6c11","excerpt":"컴퓨터 구조 storage로부터 프로그램을 읽어서 프로세스로서 메모리에 적재시키며 이를 processor인 CPU가 실행시킨다.\n 프로세스 모니터링 ps 사용법 htop 사용법 Load average 프로세스의 실행 백그라운드 Ctrl+Z : 프로세스를 백그라운드로 전환 jobs : 백그라운드에서 실행 중인 프로셋 확인 가능 fg : 백그라운드에서 실행 중인 프로세스를 포그라운드로 전환  : 4번 job을 전환 그냥 만 하게 되면 + 표시 되어있는 프로세스가 전환됨 & : 백그라운드로 프로세스 실행 bg : Stopped 된 백그라운드 프로세스를 다시 실행 시킴 항상 실행 (데몬) systemctl을 이용한 서비스 제어 : CentOS7부터는 ‘service’가 아닌 ‘systemctl’ 사용 /etc/init.d 디렉토리에는 데몬 실행 스크립트들이 모여있다. /etc/rc3.d 디렉토리에는 데몬 실행 스크립트에 대한 심볼링 링크가 모여있다. shell로 부팅되면 rc3. GUI로…","fields":{"slug":"/linux-w3/"},"frontmatter":{"categories":"Linux","title":"[리눅스 스터디] 3. 프로세스","date":"July 12, 2023"}},"next":{"fields":{"slug":"/on-premise7/"}},"previous":{"fields":{"slug":"/error-spring-mysql/"}}},{"node":{"id":"8e5edec6-07e9-579e-8b39-0199b2bd0d34","excerpt":"1. 쉘(Shell) Shell vs Kernel\n쉘은 무엇이고 커널은 무엇인가? Kernel은 H/W를 제어하는 OS에서 가장 중요한 코어와 같은 역할이다.  Shell은 유저가 직접 커널을 조작하는 것은 매우 어렵기 때문에 유저가 실행한 application을 kernel이 이해할 수 있는 형태로 변환시켜준다.\nshell도 프로그램이기 때문에 종류가 한 개만 있는 것이 아니라 bash, zsh등 여려가지가 존재하며  명령을 통해 현재 사용되고 있는 shell이 무엇인지 확인할 수 있다. 2. 쉘 스크립트(Shell script) shell script의 맨 처음에는 를 적어줌으로써 bash 쉘을 사용하는 스크립트임을 명시한다. 예시\n: 간단한 log파일 백업 스크립트 3. 디렉토리 구조 리눅스 OS의 디렉토리는 기본적으로 아래와 같은 구조를 가진다.  https://www.thegeekstuff.com/2010/09/linux-file-system-structure/ /sbin…","fields":{"slug":"/linux-w2/"},"frontmatter":{"categories":"Linux","title":"[리눅스 스터디] 2. Shell Script, 디렉토리 구조 및 파일","date":"July 04, 2023"}},"next":{"fields":{"slug":"/on-premise5/"}},"previous":{"fields":{"slug":"/on-premise6/"}}},{"node":{"id":"12da607d-f519-5b82-bb76-4a94eca42bb2","excerpt":"1. 리눅스 기초 디렉토리와 파일 기본 명령어 ls, pwd, mkdir, touch, cd, rm 등 명령어에 옵션을 붙일 수 있음 ls -al, rm -r, mkdir -p, ls -S( file size sort desc ) . , .., ~ 의 의미 —help와 man man 명령어는 전용 페이지로 넘어가서 보다 상세한 설명을 알려줌. sudo 관리자의 권한으로 명령을 실행 시 필요함. 패키지 매니저 다양한 소프트웨어들을 패키지라고 한다. 가령 ls, mkdir, man등도 모두 패키지이다.\n하지만 기본적으로 제공하는 프로그램이 아닌 다른 것들은 패키지 매니저를 통해 설치해야 한다.\n일종의 앱스토어라고 생각하면 된다. 우분투 계열의 패키지 매니저인 apt-get 사용법을 알아보자. ( redhat 계열 : yum ) htop 을 활용하면 CLI기반에서도 꽤나 GUI와 같은 형태로 리소스의 상태를 확인할 수 있다. 패키지 설치 sudo apt-get install htop 패…","fields":{"slug":"/linux-w1/"},"frontmatter":{"categories":"Linux","title":"[리눅스 스터디] 1. 리눅스 기초 & IO redirecdtion","date":"June 28, 2023"}},"next":{"fields":{"slug":"/kotlin4/"}},"previous":{"fields":{"slug":"/on-premise1/"}}},{"node":{"id":"f747237a-86f5-5b74-96bb-de33bccf8b69","excerpt":"vim 에디터를 사용할 때 .vimrc를 편집하여 아래와 같은 설정을 추가해주면 좋다.","fields":{"slug":"/vi/"},"frontmatter":{"categories":"Linux","title":"VI editor option","date":"January 18, 2023"}},"next":{"fields":{"slug":"/error-prometheus/"}},"previous":{"fields":{"slug":"/kotlin4/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}