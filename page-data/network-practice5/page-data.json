{"componentChunkName":"component---src-templates-blog-template-js","path":"/network-practice5/","result":{"data":{"cur":{"id":"fd61eeb0-5e55-5f3a-9467-0f0c5a2075e9","html":"<h3 id=\"네트워크-소켓-메모리-공간을-결정하는-커널-설정\" style=\"position:relative;\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%86%8C%EC%BC%93-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%B5%EA%B0%84%EC%9D%84-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-%EC%BB%A4%EB%84%90-%EC%84%A4%EC%A0%95\" aria-label=\"네트워크 소켓 메모리 공간을 결정하는 커널 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>네트워크 소켓 메모리 공간을 결정하는 커널 설정</h3>\n<p>kernel parameter를 runtime에 설정할 수 있게 해주는 sysctl 명령 활용</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABxElEQVQoz32S7XLaMBBFeRKMrS/rwzbEBoyxjYGQMOn7P8/pSEnT9kf7485qtNozV7u7ckbitMQajVECaxRGC1ypKY1CyRyjCrwrU85b8xXL9CbGqFirRMZKNR365cDQHzgd9+zbHcd9yzY4huA4dy+cTodUEMG/ZI2k1OJbWuYosWYV6kDpLXWwNJWj8oZt7amDIWhBbTXd1mFVjigy5H+kiozVcjlxGXuGfs9tGXncL1znkfOx47gNTK2nbwy1lQmoxOafkvHL12Vkmc/M44nn48bz7c7jtjAeO8a24roPnF8sTQTmfwOTK/EpWWw+e3ge9gzHLjm8X+fkchp6utrTby1z52mcxMg8AWNhkX99MUH/UAQ2tSU4TeVL6lBSV3F6Eqdytl5idZ4ehlKks5YZjVOUqafrb4fJZQTel4nXZeQ2n1mmgefblfs00jnNx7hlZ+Nabbj3FXNnab3gx7Rjah2lzNDFGiMydIKuWV2ngdd55DL0xPPjOvF+u7ArDc9zQ+sVThd8HDzD13Bux5Bysa8yzzDFBh17GKfstCBoidcKbySV1QSjsCInxH0TOaUoqFSBEwVluhdppVKu+C0tNvwE2cMtUUTP4sQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image1\"\n        title=\"image1\"\n        src=\"/static/ceef59f8d5d2874d28a1f3a7efff29b8/37523/image1.png\"\n        srcset=\"/static/ceef59f8d5d2874d28a1f3a7efff29b8/e9ff0/image1.png 180w,\n/static/ceef59f8d5d2874d28a1f3a7efff29b8/f21e7/image1.png 360w,\n/static/ceef59f8d5d2874d28a1f3a7efff29b8/37523/image1.png 720w,\n/static/ceef59f8d5d2874d28a1f3a7efff29b8/302a4/image1.png 1080w,\n/static/ceef59f8d5d2874d28a1f3a7efff29b8/07a9c/image1.png 1440w,\n/static/ceef59f8d5d2874d28a1f3a7efff29b8/7ad71/image1.png 2338w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<br></p>\n<ul>\n<li>net.core.*는 tcp,icmp등 프로토콜 관계없이 모든 통신과 관련한 설정</li>\n<li>net.ipv4.tcp.* 는 tcp관련 소켓 메모리 설정 값이다.</li>\n<li>이들 설정값의 단위는 다 byte단위가 아니라 어떤건 page단위(보통 4kb), 어떤 건 byte단위이다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACSklEQVQoz42TR2/bQBBG9f//QS4Bcg6CIJc4CGBHxWwSi9wiW7ZkUYUU1VhVLJJ6wS6VAMkphw+zwGDefjOzWyOzYduFzOGUWJSxTRlblaJ/4n+otvANpq5C4OkUscUpsTltu5yy7jk6nHa3nLY3lKkjo8yljjTB7yiU2NTMZ40L7QLjUSGPbYpNm+PLJfm4wVv/O/m0SWl+pHA+kzc+cLx6z/HbO/bmJ1YThWimEk5V1mOF/bJNred1GYR9Hr0u24VBvumwn16zmylsJy0Oc42DW5faDy85jH7w5tbZTVrEni4hh1Wb3dLguDGpzW0V6+sXRlqD/aItW04Dg8jTWY4VYl8n9AySoM3G00kWbbKVSewb0pmAyLZTW9bW9naHRFHZdnSKjUWZWCS+RurrvK1NUt8gmqpkvk7iaWwDnW1gyHM00zisOxJYLUUAHZOye4MAFxuTMrFlQTxT5XxEkbgg9lQpAcrmFVTksrnBYV11JrecOW0Ojk1qifmZ0qGYjWhVAAU4OztOPF22WTmtXG7Oi5GvQzjsvzg8PFk8PdscQ4uTeDrjHzCpU47r5JMmx+EVu4VGGlTu0nl1mdiscCnORWRVQHc8pKUojEZDytiRidHA/CP31eK2Z7G8vyHo3El5yj3rkYo/aBDPNDlDAZPA3s8Hmk2F+7s7ijNw7moEY53AVfGH14yfW6wGGl5PIXQNgr7C4rUltXKvCScKeWhWW17PTDaeTeTbckui5SLsUEYmRWSShx2pIjY5Rh1yodD8S+LplOdf9gv1vWeTEINItQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image2\"\n        title=\"image2\"\n        src=\"/static/5f7012d5651c0d5fb2fa16ef7ee747fc/37523/image2.png\"\n        srcset=\"/static/5f7012d5651c0d5fb2fa16ef7ee747fc/e9ff0/image2.png 180w,\n/static/5f7012d5651c0d5fb2fa16ef7ee747fc/f21e7/image2.png 360w,\n/static/5f7012d5651c0d5fb2fa16ef7ee747fc/37523/image2.png 720w,\n/static/5f7012d5651c0d5fb2fa16ef7ee747fc/302a4/image2.png 1080w,\n/static/5f7012d5651c0d5fb2fa16ef7ee747fc/07a9c/image2.png 1440w,\n/static/5f7012d5651c0d5fb2fa16ef7ee747fc/c679a/image2.png 2460w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>첫 번째 그림에서 보면 tcp 메모리 관련해서 하나의 값만 있는게 아니라 3개의 값이 존재한다. 이것은 min, pressure, max 수치이다.\n<ul>\n<li>커널을 pressure모드로 설정할 수가 있는데, 커널 내부적으로 tcp에서 메모리를 사용할 때 메모리 할당 전에 pressure모드인지 아닌지를 체크한다. pressure mode이면 pressure수치를 사용한다.</li>\n<li>커널이 pressure모드이면 리소스 활용을 최소화하고 안 쓰는 메모리 공간을 여유 메모리공간으로 할당하는 등 리소스를 타이트하게 관리하기 위한 모드이다.</li>\n</ul>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABwklEQVQoz32Sa3OaQBiF+f+/qNOkGbVeQLnHZJpEsYabgCgXxWqnPB1WMPnQ6YdnDruwZ857FqlKZ6ShzG6jcN5rUOhQalcOrZZ6i9Gq9olu36AudCQvVHnQHxjYffJUp85UAtcgDkze1xaxZ3CMZPJgQhGM2W80ouAR37VZrJ5IfINTooj3l90MyQ1VrMDC8kx2iUoVTfixeGD1s4/98pXXxR2ZOyRcDtgs+vjOCOd9hOsOmb99w1ndEy77bJYD0vUQ6egorHp3+OMeladwyWYc4hF5+J0sHAgOG5kikDlEClXc6IjTVuZ31nw/5ZyqXHYql1RFSp056pch5r1Mtr72U8UzykAm8ybkgUwZymT+hEPT81alDBWqZHrrrem9bpFi5wmzZ2ANTHLfFBfR9NGxXY/I/LEw3XtjkfQYKWKdrIdCG8M/uSaQyrcxvx41jtaUkyfDQaeKpx+m/lWbdKdkKpI2WguTq1Gdd886UhTa6M8a9otJubWg0MQ4Dc3BxrzjnM6oYkX0VReGMOjMOpX20SuTiYppzjntnqFQP/1v/6ZuR6wL7UOLq0pb38TQZOb2jGOTsNRuffyPbuRbwnb9F/Ua2LDYWYbtAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image3\"\n        title=\"image3\"\n        src=\"/static/5abc51a2e74abca15bd4eb67835876bf/37523/image3.png\"\n        srcset=\"/static/5abc51a2e74abca15bd4eb67835876bf/e9ff0/image3.png 180w,\n/static/5abc51a2e74abca15bd4eb67835876bf/f21e7/image3.png 360w,\n/static/5abc51a2e74abca15bd4eb67835876bf/37523/image3.png 720w,\n/static/5abc51a2e74abca15bd4eb67835876bf/302a4/image3.png 1080w,\n/static/5abc51a2e74abca15bd4eb67835876bf/07a9c/image3.png 1440w,\n/static/5abc51a2e74abca15bd4eb67835876bf/6f969/image3.png 2518w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>tcp_rmem, wmem은 소켓 1개 기준의 사이즈를 정의하며 byte단위이다.</li>\n<li>다운로드가 많다고 하면 read buffer를 넉넉하게 둔다면 퍼포먼스를 개선할 수 있다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABhElEQVQoz5WRaW+bQBRF+f//p+qatonBNsuAl5jYAW/gwrh4weAoabycCEwrW0pa9cPRld6b+3R1R0linXCqsZAGh42A3IZtoeKk22qWO7B1TpqLM6pdiY3ieHU+6J/ojJrsU5OHhcAftYlnbfxhi4HfIY1M1qHGMtBYhXXmUYdo1sUb3RJMHfK4Tjqrk8smihe3uUtcfNniKdFJpcZg+JEg+Io//kLv/j2L8DvLqYoc3hB518ShSvSjxiT4xjS4Qo6vSSYqP8c3KJ4U9JMuvhQ8JjpPS4M0rrGJVTKpkc1Vctkgixv8WprsU8FubbBLDfYFG5Pd2vqDYg3ueNcwMNwuj4lRGh7mRhk/i3VyqbOVOpuowfPKKns6Zm+j2J7LZ2HT8l2e11ZV8ms4paH4uLexUe6lRX/VxZNFZPOfptf3NoesOjgKeoiezWTmlh38NpzU5lhQPT5WxtPsjLO5Ek6G1GpNonDMPrUuEvytq8uDgkOlSr9nIqwm/sAuP+Qyofjvgy9py9xo8f6sJwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image4\"\n        title=\"image4\"\n        src=\"/static/80ca315c82d47f601badb8ea5a0017ff/37523/image4.png\"\n        srcset=\"/static/80ca315c82d47f601badb8ea5a0017ff/e9ff0/image4.png 180w,\n/static/80ca315c82d47f601badb8ea5a0017ff/f21e7/image4.png 360w,\n/static/80ca315c82d47f601badb8ea5a0017ff/37523/image4.png 720w,\n/static/80ca315c82d47f601badb8ea5a0017ff/302a4/image4.png 1080w,\n/static/80ca315c82d47f601badb8ea5a0017ff/07a9c/image4.png 1440w,\n/static/80ca315c82d47f601badb8ea5a0017ff/d1442/image4.png 2538w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>net.core.rmem_default, wmem_default는 tcp_rmem,wmem이 설정이 안됐을 때의 디폴트 값이면서 udp, icmp 등의 소켓 통신에 대해서도 별도의 프로토콜 별 설정이 없을 때에 대한 디폴트 값이다.</li>\n</ul>\n<hr>\n<h3 id=\"os-셋팅시-권장-커널-파라미터\" style=\"position:relative;\"><a href=\"#os-%EC%85%8B%ED%8C%85%EC%8B%9C-%EA%B6%8C%EC%9E%A5-%EC%BB%A4%EB%84%90-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0\" aria-label=\"os 셋팅시 권장 커널 파라미터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OS 셋팅시 권장 커널 파라미터</h3>\n<ul>\n<li>sysctl -a 명령으로 확인</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 재전송 패킷을 보내는 주기</span>\nnet.ipv4.tcp_keepalive_intvl <span class=\"token operator\">=</span> <span class=\"token number\">15</span>\n<span class=\"token comment\"># 손실된 TCP 상태 감지 시간 설정</span>\nnet.ipv4.tcp_keepalive_probes <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\n<span class=\"token comment\"># keep alive 시간</span>\n<span class=\"token assign-left variable\">net.ipv4.tcp_keepalive_time</span><span class=\"token operator\">=</span><span class=\"token number\">30</span>\n\n<span class=\"token comment\"># FIN 타임아웃을 시간을 줄여 FD를 빠르게 확보</span>\n<span class=\"token assign-left variable\">net.ipv4.tcp_fin_timeout</span><span class=\"token operator\">=</span><span class=\"token number\">10</span>\n\n<span class=\"token comment\"># TCP 연결에 문제가 있을 때 연결을 재시도하는 횟수</span>\n<span class=\"token assign-left variable\">net.ipv4.tcp_retries1</span><span class=\"token operator\">=</span><span class=\"token number\">3</span>\n<span class=\"token comment\"># TCP 연결을 끊기 전에 재시도하는 횟수</span>\n<span class=\"token assign-left variable\">net.ipv4.tcp_retries2</span><span class=\"token operator\">=</span><span class=\"token number\">3</span>\n\n<span class=\"token comment\"># 사용할 수 있는 포트 범위를 설정</span>\n<span class=\"token assign-left variable\">net.ipv4.ip_local_port_range</span><span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token number\">65000</span>\n<span class=\"token comment\"># TCP 수신 버퍼크기 최대값 설정</span>\n<span class=\"token assign-left variable\">net.core.rmem_max</span><span class=\"token operator\">=</span><span class=\"token number\">16777216</span>\n<span class=\"token comment\"># TCP 수신 버퍼크기 기본값 설정</span>\n<span class=\"token assign-left variable\">net.core.rmem_default</span><span class=\"token operator\">=</span><span class=\"token number\">262144</span>\n<span class=\"token comment\"># TCP 전송 버퍼크기 최대값 설정</span>\n<span class=\"token assign-left variable\">net.core.wmem_max</span><span class=\"token operator\">=</span><span class=\"token number\">16777216</span>\n<span class=\"token comment\"># TCP 전송 버퍼크기 기본값 설정</span>\n<span class=\"token assign-left variable\">net.core.wmem_default</span><span class=\"token operator\">=</span><span class=\"token number\">262144</span>\n\n<span class=\"token comment\"># 65kb 이상의 큰 TCP 윈도우 스케일링 사용</span>\n<span class=\"token assign-left variable\">net.ipv4.tcp_window_scaling</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n\n<span class=\"token comment\"># 소켓 재사용 안함:0</span>\n<span class=\"token assign-left variable\">net.ipv4.tcp_timestamps</span><span class=\"token operator\">=</span><span class=\"token number\">0</span>\n\n<span class=\"token comment\"># SYNC 패킷을 전송한 후 일부 ACK를 받지 못했을 경우 선택적으로 받지 못한 ACK 패킷을 받는지 여부</span>\n<span class=\"token assign-left variable\">net.ipv4.tcp_sack</span><span class=\"token operator\">=</span><span class=\"token number\">0</span>\n\n<span class=\"token comment\"># ESTABLISHED 상태의 소켓 수</span>\n<span class=\"token assign-left variable\">net.core.somaxconn</span><span class=\"token operator\">=</span><span class=\"token number\">50000</span>\n\n<span class=\"token comment\"># 각 네트워크 장치 별로 커널이 처리하도록 쌓아두는 queue의 크기</span>\n<span class=\"token assign-left variable\">net.core.netdev_max_backlog</span><span class=\"token operator\">=</span><span class=\"token number\">65535</span>\n\n<span class=\"token comment\"># SYN_RECEIVED 상태의 소켓 최대값</span>\n<span class=\"token assign-left variable\">net.ipv4.tcp_max_syn_backlog</span><span class=\"token operator\">=</span><span class=\"token number\">65535</span></code></pre></div>","excerpt":"네트워크 소켓 메모리 공간을 결정하는 커널 설정 kernel parameter를 runtime에 설정할 수 있게 해주는 sysctl 명령 활용 \n net.core.*는 tcp,icmp등 프로토콜 관계없이 모든 통신과 관련한 설정 net.ipv4.tcp.* 는 tcp관련 소켓 메모리 설정 값이다. 이들 설정값의 단위는 다 byte단위가 아니라 어떤건 page단위(보통 4kb), 어떤 건 byte단위이다.  첫 번째 그림에서 보면 tcp 메모리 관련해서 하나의 값만 있는게 아니라 3개의 값이 존재한다. 이것은 min, pressure, max 수치이다. 커널을 pressure모드로 설정할 수가 있는데, 커널 내부적으로 tcp에서 메모리를 사용할 때 메모리 할당 전에 pressure모드인지 아닌지를 체크한다. pressure mode이면 pressure수치를 사용한다. 커널이 pressure모드이면 리소스 활용을 최소화하고 안 쓰는 메모리 공간을 여유 메모리공간으로 할당하는 등 리소스를…","frontmatter":{"date":"January 31, 2024","title":"Write, Read 소켓 버퍼 커널 설정","categories":"Linux","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/network-practice5/"}},"next":{"id":"4671719b-df0c-5bf2-a894-d46d7933e872","html":"<h2 id=\"네트워크-io-과정\" style=\"position:relative;\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-io-%EA%B3%BC%EC%A0%95\" aria-label=\"네트워크 io 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>네트워크 I/O 과정</h2>\n<ul>\n<li>ESTABLISHED 그 이후.. Client와 Server는 서로 데이터 패킷을 주고 받게 된다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB40lEQVQoz02S3U/acBSG+4fvxmSXu1lMzEycmduyLzPd1Djwi4hQUmkpFGYVi+NDQBAo/bVQPmyfpc227OIk78Vz3rznzZECRyMQGtgquVyVlU2LlQ2Tzd1fiPsyoVsgZhyN0C0ybyQZKG/wqvvIVx/4ml7le26NducEvBJSBD45BZjp1FoV1pM/eXWoc2zUwM4SjBQCUSAYa4TTEp68g/XyOfbRe5TrT+ycr7KfW6PTOQW3iMTUIBxkmBpvYaKDe4nTOKFvHdOT15k3E4ReiaexBp5G1zSQD/I0SmWiXTwDFjcwibSO5LQz2I0zqtl3NK4SiK5M7y7FQy2F11fALcQgXhE8FfPO4kDtYdSahELD78uIykdE+4LISxLdXGzi9hREJ8NieAmzCsFDCre0Rd06w1S/Ua8cEjoq7XsZxTii2ZLB1VkOFTzzS2w4vs8gTUtbTJtHLMcay1Ee70GONU6eqfWD1v5rHs0kopsl8Mos+wnGNxvMO3ssbZXFKA+T8p8Likh+8xhT2aaq73FnHMRJopRzUaCd/kz1xTP81gX4BhNzG6d+yrCVxX9UeBqr/z7g70hR4bNhntlAYT68ZGnn486iPgaNc3xRIHT1GPZvd3m8TdC1zrBb6dg0FP+9ldD4DRImOuVRpm7DAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image1\"\n        title=\"image1\"\n        src=\"/static/c1e388c24b1ec74aac68ea9641a9efae/37523/image1.png\"\n        srcset=\"/static/c1e388c24b1ec74aac68ea9641a9efae/e9ff0/image1.png 180w,\n/static/c1e388c24b1ec74aac68ea9641a9efae/f21e7/image1.png 360w,\n/static/c1e388c24b1ec74aac68ea9641a9efae/37523/image1.png 720w,\n/static/c1e388c24b1ec74aac68ea9641a9efae/302a4/image1.png 1080w,\n/static/c1e388c24b1ec74aac68ea9641a9efae/07a9c/image1.png 1440w,\n/static/c1e388c24b1ec74aac68ea9641a9efae/365b1/image1.png 3184w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>송신 측에서 socker 버퍼에 패킷을 집어넣는다.</li>\n<li>패킷이 목적지에 도착하면 목적지인 수신 측 컴퓨터는 하드웨어 디바이스들이 직접 접근할 수 있는 메모리의 <strong>DMA 영역에 패킷을 저장한 이후에, CPU에 irq(interrupt 요청)를 보내서</strong> 패킷이 도착함을 알린다.</li>\n<li>hard irq, soft irq 과정 ( hi, si )\n<ul>\n<li>hard irq에서는 간단한 작업만을 하게 된다. interrupt를 통해 CPU를 깨우고, ISR이 해당 인터럽트에 대한 처리를 하게 함과 동시에 network stack에 event를 발생시켜 수신된 패킷이 있음을 알린다. (+flag set 정도)</li>\n<li>soft irq는 네트웍 스택에 의해 스케줄링 되며 스케줄에 따라 CPU가 soft interrupt handler를 실행시켜 수신된 패킷을 처리한다.\n<ul>\n<li>수신한 패킷 파싱, 헤더 분석, 검증(MAC, IP, PORT)이 이 때 일어난다.</li>\n</ul>\n</li>\n<li>위와 같이 실제 패킷 헤더를 까서 검증하는 등의 대부분의 절차는 si에서 일어난다. 따라서 top 명령에서도 hi보다는 si가 높다. 디도스 공격이 왔다라고 하면 si가 높아질 것이다.</li>\n</ul>\n</li>\n<li>soft interrupt handler에서 패킷 분석이 끝난 후에 이를 Socket 레이어에 전달하여 서버를 wake up 해주고 데이터를 가져가게 한다.</li>\n</ul>\n<br>\n<p>3,4 way handshaking과 같은 패킷을 주고 받을 때도 위의 시나리오와 동일하지만, 6번과정만 없다고 보면 된다.</p>\n<h3 id=\"패킷-구조와-tcp-control-flag\" style=\"position:relative;\"><a href=\"#%ED%8C%A8%ED%82%B7-%EA%B5%AC%EC%A1%B0%EC%99%80-tcp-control-flag\" aria-label=\"패킷 구조와 tcp control flag permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>패킷 구조와 TCP control flag</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABuElEQVQoz12Qa3OaQBSG+f+/pN+a1EzTmXgJVgMILIoXKo2JooY0ikAwF69Ph42NYz88s7vn7HnnfY+yTW3WickqbrBJLDaJYBUL3hdC3reJzS5qsJ3r7BamfG9im/VMsJ4LNjmRYLOwZU/xhjqaV0Hrl2jdG5h+yA8r5KLxgNpbEAqH6OqC6PIbcbXIyPXxmlNapQC3MsatBrjlMT3tAb8zRmn36xhuFatbw/F1dC+gYt5SFXf8bIdMRZNRrchErxJq1wSuT787xTE7CKODpbsIo0vXGdBvBygyQh41tg6RbRk1j/U6N3mbm7zPTV5nDd5mBm+zhry//DFYRebHXGyxXlhyRtk/C06xDwjSQCUdXpONVLKxSjKpsRhXycI6z2GdbWJBdjqr7FKbI+KAzT5zWA5KZL3vRM45M3FO6JeIgrp0nJP/zYWOcyJ3aLPLi/I8kNqQOYz7RR7vVTpWAXHzlV92gWRyQzrVpPDy0fgQTR12B5R97kYWj/wTDLwrwt9lOsYZevkLLe2MpztVust3+fJksE3+EzxxduJQMBuqpNM6A/cSzyoQ3pZh2ZQx8/7n/j4jO/wFwqKK68JR7EQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image2\"\n        title=\"image2\"\n        src=\"/static/43356176b16deff2b3b78de9e5d40fca/37523/image2.png\"\n        srcset=\"/static/43356176b16deff2b3b78de9e5d40fca/e9ff0/image2.png 180w,\n/static/43356176b16deff2b3b78de9e5d40fca/f21e7/image2.png 360w,\n/static/43356176b16deff2b3b78de9e5d40fca/37523/image2.png 720w,\n/static/43356176b16deff2b3b78de9e5d40fca/302a4/image2.png 1080w,\n/static/43356176b16deff2b3b78de9e5d40fca/07a9c/image2.png 1440w,\n/static/43356176b16deff2b3b78de9e5d40fca/84bc0/image2.png 3176w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>PSH 플래그는 어떤 경우인가? socket마다 send 버퍼, receive버퍼가 있어서 커널 레벨에서 버퍼가 채워질 때까지 기다릴 수 있다. PSH 플래그를 set하면 버퍼에서 대기하지 않고 바로 어플리케이션 서버로 wake up 요청이 들어가게 된다.</li>\n</ul>\n<h3 id=\"socket-통신-내부-구조\" style=\"position:relative;\"><a href=\"#socket-%ED%86%B5%EC%8B%A0-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0\" aria-label=\"socket 통신 내부 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Socket 통신 내부 구조</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABjklEQVQoz1WRa2/aMBiF+f8/aB8mVdogJZRgOxRWILAEmoSWW+5ZKSQ8VS4T24dHsi2/x8fndI6vivNRQibI3wXj3gBTH5PsFKSCMr5zSyRlLLklglv6D8n9TufjpLhGklsqKSKDeKmRuwPKxGiGW6p1GTVDRSC5HFTDXtX7v491Ln6Pz51OvtXJfZ3LYcj5/YnM08l2feJdj+z4SJkIyExIJeetIrZMooUino/52Kraae2wPA0pAoPY6hHNupSuQemOKDyD83FI4Hd5sx+IfI3Q6/IZDCGTXGMDctmQVg5V47D66jUSrDcDbHfE2hc4nuDVMygiQREKkm2f9fQ78+E3DiuN7G3AJTDqiIqwYsg1GNSZd6pAK0HT0lCOwctWMfEVC19wCUeQqlo43PRJbUm8Uuztn+wdjeWzzkz1GT9paA8/WE1HrWAomT/PmIgVyxcXa+phz2yu4b1ZsqqEx7oscrM++wzMmvOpYsyfg2oEi0jy+9cEa7JgYzk4Cwd3tfxPsGm5pW2epCUVLZIvzgxJGfG8zcYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image4\"\n        title=\"image4\"\n        src=\"/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/37523/image4.png\"\n        srcset=\"/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/e9ff0/image4.png 180w,\n/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/f21e7/image4.png 360w,\n/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/37523/image4.png 720w,\n/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/302a4/image4.png 1080w,\n/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/07a9c/image4.png 1440w,\n/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/9d362/image4.png 3278w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>socket() systemcall은 file을 open하는 것과 마찬가지로 file descriptor를 반환한다. 그리고 process마다 가지고 있는 fd table에 이를 추가가 되는 형태이다.</p>\n<blockquote>\n<p>프로세스가 파일을 열면, OS는 새로운 fd를 할당해주고, 파일을 닫을 때는 해당 파일 디스크립터를 해제한다. fd table 통해 각 fd에 연결된 파일 or 소켓 등의 정보를 추적하여 프로세스가 I/O 리소스에 접근할 수 있다.\n왜 socket()은 file descriptor를 반환하는가? 리눅스에서는 네트웍 자원을 포함하여 모든 리소스를 사용할 때 VFS를 통해서 하기 떄문이다.</p>\n</blockquote>\n</li>\n<li>\n<p>open() syscall이든 socket() syscall이든 fd table에 VFS의 주요 자료구조인 <code class=\"language-text\">struct file</code>이라는 구조체를 만들어주는 것은 매한가지이며 fd는 이 구조체를 가리키는 참조이다. 파일이라면 struct file이 struct inode와 연결될 것이고 socket이라면 struct socket이 연결될 것이라는 차이점이 있다.</p>\n<blockquote>\n<p>하나의 프로세스가 여러개의 socket을 유지할 수 있다.</p>\n<ul>\n<li>process 당 fd table은 1개이지만 process가 열 수 있는 file의 개수는 여러 개임과 같은 맥락이다.(fd도 여러개)</li>\n<li>process가 open할 수 있는 파일의 개수를 확인하려면 아래 명령을 실행해보면 기본적으로는 1024임을 알 수 있다.</li>\n<li><code class=\"language-text\">ulimit -a | grep \"open file\"</code>\n<ul>\n<li>관련 에러: <code class=\"language-text\">\"Too many open file\"</code> -> 파일이라는 단어를 보더라도 클라이언트와의 소켓 커넥션과 연관지어 생각할 수 있어야 한다.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABjklEQVQoz2WSTW/aQBCG/f9/QNVDD604VFEvVVRECSmqZDvFxl+kCYQCaRwRLAwEr9cKpth+KmOSoPbwaFa7s+/szjvKyv9OLj3S+3NW+jv+zDUK6VHENkXs7MmPKIRdxaPzcp2LKirIKnEbqMjBKTyaZMJmt+6yW1vkkQXC3rMXEzZZVJGL/1HETGO7NFjMVK5GTYbjJpulQXYQSxYmvq9z7+tsHi14ciB1K5LDCxO3QrqVYFl9ctvis/qBtvOJdN2FxIPYYREYODcqlyOdeGEy9kz0cx3tTOOu36WITNKpyvZBZRf+QKFUjh2QLmwuyVZdwkmbONCqr60typyyNUibn5ZJs37B11OdUd8lHbYY195w+/EtQb2G8m8PSpFoquJfNyiE87ovSkGLi6sx75tDau3f9EYTEAbb0CRbmuzmHZQXhw6X9yYJGxnolcMvxSoXRdjjwff4Negw8zvEgzPmrRPkzTd48lCex6C8VBzFsgWvQs+jYUNiU0QG0/4X7q7rhL0Gi9YJwm1QSIe/CjxFIiRi8iUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image3\"\n        title=\"image3\"\n        src=\"/static/1497f55a8ef034196ea8ca5f51071256/37523/image3.png\"\n        srcset=\"/static/1497f55a8ef034196ea8ca5f51071256/e9ff0/image3.png 180w,\n/static/1497f55a8ef034196ea8ca5f51071256/f21e7/image3.png 360w,\n/static/1497f55a8ef034196ea8ca5f51071256/37523/image3.png 720w,\n/static/1497f55a8ef034196ea8ca5f51071256/302a4/image3.png 1080w,\n/static/1497f55a8ef034196ea8ca5f51071256/07a9c/image3.png 1440w,\n/static/1497f55a8ef034196ea8ca5f51071256/3bb53/image3.png 3286w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>struct socket도 자세히 들여다보면 struct sock으로 구성되어 있고, 이것이 우리가 말하는 “socket”의 실체이다. struct sock은 receive/read queue를 가지고 있고 해당 큐에서 패킷을 보관한다.\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;net/sock.h></span></span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 다양한 소켓 관련 필드들...</span>\n\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff_head</span> sk_receive_queue<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 수신 큐 (Read Queue)</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff_head</span> sk_write_queue<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 전송 큐 (Write Queue)</span>\n\n    <span class=\"token comment\">// 다양한 소켓 관련 필드들...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>리눅스 커널에서 패킷은 sk_buff라는 구조체에 저장하며 아래와 같이 구성되어 있다.\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 패킷의 데이터를 저장하는 버퍼</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>data<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 버퍼의 길이</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 네트워크 계층의 정보, 전송 계층의 정보, 애플리케이션 계층의 정보 등을 포함하는 다양한 필드들...</span>\n    \n    <span class=\"token comment\">// 다음 패킷을 가리키는 포인터 (리스트 구조체로 구성된 큐에서 사용됨)</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff</span> <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>","frontmatter":{"date":"January 25, 2024","title":"리눅스 네트워크 I/O 분석","categories":"Linux","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/network-practice4/"}},"prev":{"id":"2c244566-102b-527a-a252-0675250dd9af","html":"<h3 id=\"mss란\" style=\"position:relative;\"><a href=\"#mss%EB%9E%80\" aria-label=\"mss란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MSS란?</h3>\n<ul>\n<li>L4계층의 개념이며 Maximum segment size의 약자로서 TCP에서 전송할 수 있는 사용자 payload 크기\n<ul>\n<li>TCP header를 제외한 payload만의 크기이다. 그리고 payload는 각 네트웍 계층에 따라 상대적인 개념이다. (ex. L4에서는 http 헤더가 payload. L3에서는 tcp헤더도 payload)\n<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACA0lEQVQoz1WQ3XKaABhEef/n6U3TmTZJTUAQFAQUUEFENMqvghojno6av16c2flu9ttdocllTqtHTusWp+SJplQ5b7R3VXnNNF48k7VnsZ7cSAKTZWwzGtsEwYAwHBBMB2SrPsLF5Dj9wTH6yXF+R1N03g012Kjsky4TdYgvO/iagy+7TLtDxoGHqI5od0d09BHP6og4thGajcq56l4TXcnlL0oFtgrsRTiIN62foHqC7eV+ht03ShGhyWTe4tY1WVN2Po0vdY9LiV0okoc6eaBThDqp3yMLuuQvBvHUYBkaLGcGi9Bgu+4hnFKZY/j4ud1H3abqUTsPpMpvPHmE1/IYtz1GosdEdRlOxvyRJvxVJjxrEx4Un9l8iHAu1etWp0z5D4o2VB2oNdhJcJBuupeglqCUbhPsvlG0EXaJyipSYHOre3lwLhSC0GFhyWzNe0JjwEyziXSbmW4ztyyC6RC156D3Hfq2g2G7rBYmwi7Vrt2bsscx7/KaazS5ij+1mdsSuXnP1OwT6gYzyyDqW0S2iR/0MUwL07awBha9vs1ibiAcc5k4umMe/aJctzjkKkP/nnxtUhVjNpsxVemyLVy2ucsskIkChTrz2OUOu9yl/iAxEU6FSpWI1KnIWylzWGs4UodQGxDrLi+WQzp2qLMBVWKTzrtkce92p19skwH7zOAffE7X/fffW/gAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image2\"\n        title=\"image2\"\n        src=\"/static/2bc16affef3fb4aa9fef722a325d414a/37523/image2.png\"\n        srcset=\"/static/2bc16affef3fb4aa9fef722a325d414a/e9ff0/image2.png 180w,\n/static/2bc16affef3fb4aa9fef722a325d414a/f21e7/image2.png 360w,\n/static/2bc16affef3fb4aa9fef722a325d414a/37523/image2.png 720w,\n/static/2bc16affef3fb4aa9fef722a325d414a/302a4/image2.png 1080w,\n/static/2bc16affef3fb4aa9fef722a325d414a/07a9c/image2.png 1440w,\n/static/2bc16affef3fb4aa9fef722a325d414a/f705e/image2.png 2998w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<br>\n<ul>\n<li>그리고 전 layer에 걸쳐서 ethernet frame을 포함하여 패킷은 sk_buff 구조체로 리눅스 커널 내부에서는 관리된다.</li>\n</ul>\n</li>\n<li>MSS는 말 그대로 최대치를 의미하며 이것 보다 큰 데이터는 fragment로 조각을 내서 전송한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"mtu란\" style=\"position:relative;\"><a href=\"#mtu%EB%9E%80\" aria-label=\"mtu란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MTU란?</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACH0lEQVQoz2WTS2/aQBRG+f/bbrqpqqqVusmuURMpiaJQEwzYmEDbEFBsEh4x4+cY2+QBnGqMIYm6OLqvme/ac2cqa9mGhQmZAakBmQV5Z2szE3JjS2a891Ut2+0zUTqbxKRCYiJFh7v7PpP736SOTn5bQ9o64q7LfNhjPughnB7CLnF6eKNuSY9wYhViSrRC0sQZ9flclfxs+YijI/yPH7g7O8esu1Q/uVS/uGjfXbSvLvqBS/3gAe2bYoZ+OOdvd8gmMXaCJtGsgZhe4U8t0rHOclInuP2FP6wRjU2icYvQaRFN2sQPFtHYILANAkfZJuLmgnVisknaVNbSZOnVYWEUZ7lZtCG/YulqPI1OWXs1VnOtsE+DIx7/HLKaXRRxgVsls0/KM9wLNopgU3QxUV9ddEwtWJSkFs+jcx6HJ6yDBqSdbfPUYuk3UTp7QTmrkQmDzDPIvTdWbFF+rmzQJg8tcs98VwvvNVbxXrDJxDYQvsT3Qzw/KgkJwpjxZMbx8QnX1wOiKEGIoKjt1viBZHTb5yVq7QQN5EMLKQZI0ScpuCl86fWJ59dMbQNv0iXxyvwb1Npg2nn95Y1sk7gaz1GdVdxgFel7XiKdjWxuL3nS2ubj97zEOlINaSdI0ib1Lsn8Ok9hk8ewsec5ahLPq9jOD8Ts7L+6ivNAR861/VCLoRRTTKwyaZWoJ9kh8y+Zjo+JRfXNmldUTu1flzfjH7y/bkkOzrXtAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image1\"\n        title=\"image1\"\n        src=\"/static/faac02b9ff96a3a43c0e95d4986c1e08/37523/image1.png\"\n        srcset=\"/static/faac02b9ff96a3a43c0e95d4986c1e08/e9ff0/image1.png 180w,\n/static/faac02b9ff96a3a43c0e95d4986c1e08/f21e7/image1.png 360w,\n/static/faac02b9ff96a3a43c0e95d4986c1e08/37523/image1.png 720w,\n/static/faac02b9ff96a3a43c0e95d4986c1e08/302a4/image1.png 1080w,\n/static/faac02b9ff96a3a43c0e95d4986c1e08/07a9c/image1.png 1440w,\n/static/faac02b9ff96a3a43c0e95d4986c1e08/c211c/image1.png 1502w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>L3계층의 개념이며 Maximum Transmission Unit의 약자로서 네트욱에서 전송할 수 있는 최대 패킷 크기이다.</li>\n<li>라우터 마다 이 설정이 다를 수 있다. 예컨대 내 PC는 1000byte가 MTU여서 1000byte를 보냈더라도 중간에 어떤 라우터의 MTU가 700이면 패킷을 쪼개서 700을 먼저 보내고 300을 보내게 된다.</li>\n</ul>\n<h4 id=\"mtu값-확인하기\" style=\"position:relative;\"><a href=\"#mtu%EA%B0%92-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\" aria-label=\"mtu값 확인하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MTU값 확인하기</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABKElEQVQY002Q2W6DMBRE+ZIkgAEDXjBboTEk6aKqi9T//5pT2VWqPozueGQfzXUyjY55dFjd4KyiMy1tdsCpI1pVaN3SWU3bSIa+Yx77eA7emjaqswqjG2QlSJbJsW+PXP3Cvk4833b8w8i29vgHh58Hrn5gnQesqnGmxbQyFjCqjgXuWSVSks+PN77eX/l+u3DxK7tf2c4L192znxf2qefme5a5x5mwQRMhEWQVo9NYXUd4GYAvTxdeb1tseLtunOeO/XGidyY+GnrLFNYM3pm/VqGhDr4tkeJIdjogsiNJXUsaWVLLgroqaOoSWRVURUYhMor8hBQpVZlTFTmlyMjTw6+yY5TIT/FemIkyClmKqBAWIo0qIzCN/9KIU4Tfs/+A+xT5L/gHqIq3QUl2GqAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image3\"\n        title=\"image3\"\n        src=\"/static/581b328f589f1d25956f1ce7ecd240ff/37523/image3.png\"\n        srcset=\"/static/581b328f589f1d25956f1ce7ecd240ff/e9ff0/image3.png 180w,\n/static/581b328f589f1d25956f1ce7ecd240ff/f21e7/image3.png 360w,\n/static/581b328f589f1d25956f1ce7ecd240ff/37523/image3.png 720w,\n/static/581b328f589f1d25956f1ce7ecd240ff/302a4/image3.png 1080w,\n/static/581b328f589f1d25956f1ce7ecd240ff/07a9c/image3.png 1440w,\n/static/581b328f589f1d25956f1ce7ecd240ff/ea66f/image3.png 2828w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>enp0s3 의 mtu가 1500임을 확인가능</li>\n</ul>\n<h4 id=\"mtu값-계산하면서-ping-날려보기\" style=\"position:relative;\"><a href=\"#mtu%EA%B0%92-%EA%B3%84%EC%82%B0%ED%95%98%EB%A9%B4%EC%84%9C-ping-%EB%82%A0%EB%A0%A4%EB%B3%B4%EA%B8%B0\" aria-label=\"mtu값 계산하면서 ping 날려보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MTU값 계산하면서 ping 날려보기</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB5ElEQVQoz32S63KbMBCFeRLbGKE7EhcDBlzbTeJO3/+Fvg7CSZpO2x/f7GhnOZzVUSZFjjMaZxTeaowq8Vals5ICWR4TKlEgjnvK4vDJcaui2PqZj4G43OmawDj2tNFxOzdMQ8tt7glOE7zGapF+VFlJke8S7+KpPsnG1vPzcWeZeh6v37mMLT/e1vNAO83U85V5WWiGkft0IpwX2lgxdJFY2SS8OdzInMzp20hbB7o60FSGoauJ3nB0gTI0OGvR1tGs7lygWwXbQPQWcdgh0+p75OpQy5LKuXSPVku0FFTOYKVApaFdGpRppe1Dsa77XFkeDx/9TbAskps1EGsUNoViCd6hlUSI/BlA/jWM4jOMjU00U1pim446eGKskrux8XTRce47GqPQqkzOtRIYXX4J4U+ytm2Ybvd0b5fLRN9F3q4j89jwMjW8nk8MfUvf1XRNTGGss6uo+C2Mj1B6p/gWHPM8cL1MzOeecTjxeHvh9eXKspy5X2emZcJ2M48p0laK478EvSwISuB0SWUUlZY4Jai9TXgtU98bhZSKoAq0eA/h8BHYO5kqjlitcapMmFJQGYkuDuh8n5Dr0zjs0KnuUc/+38iUUshmJFSOWAe8lQxBpTc3nVqiM5T5HlXkT0f/5xelJGRG5hw0GQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image4\"\n        title=\"image4\"\n        src=\"/static/03486d2b37ce46fd76d1d6c521a6f0d8/37523/image4.png\"\n        srcset=\"/static/03486d2b37ce46fd76d1d6c521a6f0d8/e9ff0/image4.png 180w,\n/static/03486d2b37ce46fd76d1d6c521a6f0d8/f21e7/image4.png 360w,\n/static/03486d2b37ce46fd76d1d6c521a6f0d8/37523/image4.png 720w,\n/static/03486d2b37ce46fd76d1d6c521a6f0d8/302a4/image4.png 1080w,\n/static/03486d2b37ce46fd76d1d6c521a6f0d8/07a9c/image4.png 1440w,\n/static/03486d2b37ce46fd76d1d6c521a6f0d8/8079d/image4.png 2100w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>s옵션을 통해 68byte짜리 패킷 전송</li>\n<li>MTU값 보다 큰 패킷에 대해서는 쪼개서 전송되어야 하지만 ping이라는 프로그램에서 MTU값이 넘는 패킷에 대해서 전송하지 않는 것이다.</li>\n<li>icmp헤더(28byte)까지 고려하여 1472로 size를 설정해서 패킷을 보내면 전송은 되지만 구글서버에서 응답을 안해주는 걸 확인가능</li>\n</ul>\n<h4 id=\"mtumss값-계산하면서-hping3-날려보기\" style=\"position:relative;\"><a href=\"#mtumss%EA%B0%92-%EA%B3%84%EC%82%B0%ED%95%98%EB%A9%B4%EC%84%9C-hping3-%EB%82%A0%EB%A0%A4%EB%B3%B4%EA%B8%B0\" aria-label=\"mtumss값 계산하면서 hping3 날려보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MTU/MSS값 계산하면서 hping3 날려보기</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABM0lEQVQoz32SbW7bMBBEdZLUkshdckla1JdVpwjQ+1/qFVSMIEbd/ngYgMDOcobsVIWYEteSyKZY8KjryVGI6nDDj7/w4wXf9AWdqKJlok6FWhL1mjF13LaFkiJj/4a4/otmdho3fUGnZsRpYd9W9nVmzkotke0a2efCsW9YaLf1xCB41+PG/xh6N+C9I6gjyHjG9cMbwfcEP6Ay4obLt8iXlzW4/lM7DUpIibkWpkeP61K55vhJCmQTcg4kU3JWYhxR6QnaFg4EGbDHWedFcCFRUjOLmApLrWfMZEZqC3UkZ8GiI5k/h5tZfGjDzKG+p6vF8/FuHFvkfjPuu/C+Kceq/P4V+LjHs1Nx49mhuIGxf475FFmiEuvEsVVuS2HNjtskTDbwcxaOrVCSnK/99G3+wR8uQOkbIBsLrwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image5\"\n        title=\"image5\"\n        src=\"/static/51479068a57314d3819df2a7d12098c6/37523/image5.png\"\n        srcset=\"/static/51479068a57314d3819df2a7d12098c6/e9ff0/image5.png 180w,\n/static/51479068a57314d3819df2a7d12098c6/f21e7/image5.png 360w,\n/static/51479068a57314d3819df2a7d12098c6/37523/image5.png 720w,\n/static/51479068a57314d3819df2a7d12098c6/302a4/image5.png 1080w,\n/static/51479068a57314d3819df2a7d12098c6/07a9c/image5.png 1440w,\n/static/51479068a57314d3819df2a7d12098c6/43300/image5.png 2694w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>hping3에서는 MTU값보다 패킷이 커도 나누어서 전송함을 확인가능(“IPv4 Fragmented IP Protocol …” 메시지를 tshark에서 확인 가능)하지만 여전히 구글 서버로부터 응답은 되지 않음</li>\n<li>MTU를 68에서 점점 늘려가다보면 구글에서 MTU 사이즈를 어디까지 응답해주는지 확인 가능하다.</li>\n</ul>","frontmatter":{"date":"January 31, 2024","title":"MTU와 MSS 이해와 실습","categories":"Linux","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/network-practice6/"}},"site":{"siteMetadata":{"siteUrl":"https://jjunyong.github.io","comments":{"utterances":{"repo":"jjunyong/jjunyong.github.io"}}}}},"pageContext":{"slug":"/network-practice5/","nextSlug":"/network-practice4/","prevSlug":"/network-practice6/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}