{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/error-json-serialize/",
    "result": {"data":{"cur":{"id":"cbd47f43-f6c1-584b-ba41-4fd008565526","html":"<p>Type definition error: [simple type, class stg.onyou.service.CursorResult]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class stg.onyou.service.CursorResult and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: stg.onyou.model.network.Header[“data”])“,</p>\n<p>RestController에서 return 시 객체를 json으로 serialize하는데, 이 때 객체의 멤버 중에 Getter가 없는 멤버 변수가 있어서 발생한 에러이다.</p>\n<p>간단하게 Getter를 직접 설정해주거나,</p>\n<p>아니면 @Getter 어노테이션만 추가해주면 해결된다.</p>","excerpt":"Type definition error: [simple type, class stg.onyou.service.CursorResult]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class stg.onyou.service.CursorResult and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: stg.onyou.model.network.Header[“data”])“, RestController에서 return 시 객체를 json으로 serialize하는데, 이 때 객체의 멤버 중에 Getter가 없는 멤버 변수가 있어서…","frontmatter":{"date":"March 27, 2022","title":"[Error] Getter가 없어서 발생하는 JSON Serialize 에러","categories":"Error","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/error-json-serialize/"}},"next":{"id":"82e6428f-f8dc-5910-93fa-96947ef11565","html":"<h2 id=\"1-jpa에서-프록시란-무엇인가\" style=\"position:relative;\"><a href=\"#1-jpa%EC%97%90%EC%84%9C-%ED%94%84%EB%A1%9D%EC%8B%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"1 jpa에서 프록시란 무엇인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. JPA에서 프록시란 무엇인가?</h2>\n<h3 id=\"1-emfind-vs-emgetreference\" style=\"position:relative;\"><a href=\"#1-emfind-vs-emgetreference\" aria-label=\"1 emfind vs emgetreference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) em.find vs em.getReference</h3>\n<p>em.find를 하게 되면 JPA가 실제 entity 객체를 반환하지만,</p>\n<p>em.getReference를 하게 되면 DB조회를 미루는 ‘프록시’ entity 객체를 반환한다.</p>\n<p>프록시 객체는 실제 Entity 타깃 객체는 가지고 있지 않고, id값만 가지고 있는 비어있는 객체이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABC0lEQVQoz5VS24qDUAz0/3+kfe+z4KLFCxYEi0URBPFFj1WrrXedJYHKsmy7u4EwnJwwkwyRxnHEuq6geOJv8b3v61u6XC4YhmErzPOMZVnQ9z3atgUJ0pt6KOu65roQAmEYIssydF2HsigZJcdx8Hg8WGWaJnieB9u2oSgKFOUDx+MRuq4zJkkC6nddF6ZpYr/b43Q64Xw+M3lRFJCyTPBkt+qGsixRVRV/ENI0hFS/3++IogiqquJwOEDTNBaP4xi0JYkxIRVosr8ErWQYBmRZhmVZ8H0feZ6z6EYYBAGaptnMfZUU5OX1eoUQOXuYpikj+UjENJhERlPjO8L/XID06hR+Oot3GzzzE4D5ZCURMAveAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image1\"\n        title=\"image1\"\n        src=\"/static/835023913ed13c3757f317293e052c76/37523/image1.png\"\n        srcset=\"/static/835023913ed13c3757f317293e052c76/e9ff0/image1.png 180w,\n/static/835023913ed13c3757f317293e052c76/f21e7/image1.png 360w,\n/static/835023913ed13c3757f317293e052c76/37523/image1.png 720w,\n/static/835023913ed13c3757f317293e052c76/612f7/image1.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>프록시 객체는 실제 Entity를 상속해서 만들어지며, Hibernate가 내부적으로 만든다.</p>\n<p>실제 클래스와 겉 모양이 같기 때문에 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용할 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 338px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 206.1111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAApCAYAAAA1bQl+AAAACXBIWXMAABYlAAAWJQFJUiTwAAAElUlEQVRIx7WXZ09iURCG+a3+Dz/qFxMTTewKxGQt2HUFLNi7AtLE3ksEe6/M5hlzrndR3HWTnWRyuefMmTPtvjM4RESurq4kHA5LNBqTaDSqHIlEJR6PK6+ursrKyoo+l5eXdc3I2fn5+VkcKIzFYpJILMn9/b1cXFzKxcWFbg4MDIjH45FQKCT9/f3S1NQkyaWkHB0dyc3NjVxevsk+Pj7K2NiYpNPpd4UHBweSTePj49LQ0CDV1dVSV1cnxcXFUlJSInt7ex9kg8GgpFKpN4WLi4vS09MjkUhEpqamZGFhQa2amJhQy2ZnZ9WCyclJaW9v130UwPPz8+puc3Pzu4XEJJFI6AEOPj09qRu4nclk9Pn6+iovLy9qDfuGHx4edG1mZkaOj4/fFW6sb8jS0pJsbm5+cAeln/22v2O15TIx3Nra0iCfnJzI7u6uxpTgn5+ff6rIEJZDuG4pxDKUzs3NSWtrq8YTgc7OTi0VCHc5nM0mDJz9LSler9dKxOjoqMZyeHhYlZIo6tQkIhgMqSzMO8ZQXlZSSAhx5GBbW5v4/X7xen3i8/k0q8lkUq0hASQINkkheSYploUo5Eug7rgtlUrLzs6ObGxsqLLb21srZrj4WZIW5m1JwTqSwsLh4aEqwl2UnZ6eytramiaJPdxE9ssso9AUt9PplKGhIWXcJ4a4HgqGpLGxUdfxCEvtLk9PT7/XIe5VVFRIUVGRVFZWSm1trbicLn1WVVVJTU2N5Ofn6+dXVlYm1dU14na79XKXyyV1TqfU19draBzGZG4yNxJ8GLBgH4QJBIbUbd5Zt/Pd3Z0mClKFuYoWAlU6Ojpkbm5eS+srQo/D/MjFEMngO8cak+VcbLmcrcSeQVwicXa5D992xmZhLvON8PX1tUJbrovt5PhTTHIpzEX/V6FdONtlUPmvFdqVAAL257cV2pXlon+2kIN0tLOzM0Vt0y++baGBcYCgsLBQv+G8vDzp7e3VdVrDtyw0CkHpgoICRWyQpbu7W9dp5ibLuVqBibkju+rBPzuYQrjOxPA35DB9Fggjbny3/AZEQRdAE4BlLDF78Pb2trKRZc/69FaWV7SfIECXQwGCuA7e0QFpUnRHWgW8vr6uvLq6JtvbOzph0HJVIQEns9kEINBWAVZiWl5erihuYp4tayE28M8N9BAzmgHzpn329fVJS0uLdHV1KYKzRjN7G/siCsBcZLVRFmGySczY4EmCmCRYZ4Y0zBoy6fSJylGn9BqrSXETtwDj9AU7tIPYHKAWjULeDbNOUmnBlkJcoLHPzszq5ECXowZ//uwVt8utLZVLCU04vKjy/IZDobCGx+NpkVTq2Mw2Sc3syMiIBp8CHxsbVzeI7f7+/h/rj0t+G+cohbepIaVuUFtMX8TK9F6IQ8TUzI24CzGUvo8i8YQWNXXFjGJCQFyI7cTEpD6ZsDj42QxJUi0LY7G4AkNpaanO0Gako5nT5Ftb28Tb69VZ+8ePBi0j4mb+LXAZQ5VVNhS13+dXJSRgcHBQPzWaeyAQkMHBgL6zR0xR6Pf36ZTGk35tRmnHV1D0fcrILzMgyWew/71eAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image2\"\n        title=\"image2\"\n        src=\"/static/a7e3860d5829674a4505da8f3c996663/2b41d/image2.png\"\n        srcset=\"/static/a7e3860d5829674a4505da8f3c996663/e9ff0/image2.png 180w,\n/static/a7e3860d5829674a4505da8f3c996663/2b41d/image2.png 338w\"\n        sizes=\"(max-width: 338px) 100vw, 338px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>프록시 객체는 실제 객체의 참조(target)를 보관하고, 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.</p>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">\b<span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">getReference</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"id1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmembmer<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n<p>이렇게 호출을 한다고 생각해보자.</p>\n<p>getName 호출하게 되면 MemberProxy객체에 target이 없기 때문에 JPA가 영속성 컨텍스트에 진짜 Member객체 가져오라고 초기화 요청을 하게 되고, 영속성 컨텍스트는 DB를 조회해서 실제 Member 엔티티 객체를 생성해준다.</p>\n<p>그리고 Proxy와 진짜 객체를 연결해주어 getName()을 했을 때 target.getName()을 통해서 진짜 엔티티 객체로부터 값을 가져오게 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABF0lEQVQY031Ry4qDUAz1/z9kunDXZUGwGx0tdLS2UopvLdVW+1DEtj7OkAwOMosJhJtLTpKTE6Hve0xt/D+fT3ieh+PxiCzLcLlccD6fUdc1hmFA27Z4v994vV6/cdd1EMqyRBAEME0TaZrier3idrsxiBqSR1EEx3EY1zQNYyg+HA4QRRGapnGt7/sQFEXBcrnE7GOG+XyOMAzhui43HI0YTV8aYFkWHo8SRVEwgaqqkCQJBFmWIUkS9vs9NpsN8jxnVgQkJn+dirfbLVT1E7qusxQkD+XiOP5hqKoqg4Ig5OTpdMJ/RkMXiwVvRlLRVvf7nZkLu92OtaDXtm1el9iNK059PBixXK1WMAwD6/UXDMNk/eiA30ASvJtRl37AAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image3\"\n        title=\"image3\"\n        src=\"/static/d89fd057014a0a8083cf8726068048f8/37523/image3.png\"\n        srcset=\"/static/d89fd057014a0a8083cf8726068048f8/e9ff0/image3.png 180w,\n/static/d89fd057014a0a8083cf8726068048f8/f21e7/image3.png 360w,\n/static/d89fd057014a0a8083cf8726068048f8/37523/image3.png 720w,\n/static/d89fd057014a0a8083cf8726068048f8/612f7/image3.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"2-proxy-객체의-특징\" style=\"position:relative;\"><a href=\"#2-proxy-%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"2 proxy 객체의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Proxy 객체의 특징</h2>\n<p>(1) 프록시 객체는 처음 사용할 때 한 번만 초기화 된다.</p>\n<p>(2) 프록시 객체가 실제 entity로 바뀌는게 아니라 프록시 객체를 통해 실제 entity로 접근하게 되는 것이다.</p>\n<p>(3) 프록시 객체는 원본 엔티티를 상속받은 객체기 때문에 타입 비교 시에 ’==’ 대신 ‘instance of’를 사용한다.</p>\n<ul>\n<li>JPA에서 타입 비교시 instance of 사용을 권장하는 이유임</li>\n</ul>\n<p>(4) 영속성 컨텍스트에 찾는 엔티티가 이미 존재한다면, em.getReference 호출 시에도 실제 엔티티를 반환한다.</p>\n<ul>\n<li>\n<p>반대로, 이미 getReference로 반환했다면 동일한 id로 find를 해도 proxy객체를 반환한다.</p>\n</li>\n<li>\n<p>JPA에서는 동일한 데이터에 대해서 ’==’ 비교를 true로 해주는 것이 보장되어야 하기 때문이다.</p>\n</li>\n</ul>\n<p>(5) 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때 프록시를 초기화 시에 에러가 발생한다.(종종 발생!)</p>\n<ul>\n<li>org.hibernate.LazyInitializationException</li>\n</ul>\n<p>​</p>\n<h2 id=\"3-프록시-확인\" style=\"position:relative;\"><a href=\"#3-%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%99%95%EC%9D%B8\" aria-label=\"3 프록시 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 프록시 확인</h2>\n<p>(1) 프록시 인스턴스 초기화 여부 확인</p>\n<ul>\n<li>PersistenceUnitUtil.isLoaded(entity)</li>\n</ul>\n<p>(2) 프록시 클래스 확인 방법</p>\n<ul>\n<li>entity.getClass()해서 찍어봐야 함</li>\n</ul>\n<p>(3) 프록시 강제초기화</p>\n<ul>\n<li>\n<p>Hibernate.initialize(entity) // JPA 표준에는 없음</p>\n</li>\n<li>\n<p>entity.getUserName() 이런식으로 실제 entity의 멤버값을 호출하면 강제 초기화 됨.</p>\n</li>\n</ul>\n<hr>\n<p>그리고 이렇게 JPA의 Proxy에 대해  설명한 것은 즉시로딩과 지연로딩에 대해서 이해하기 위함이다.</p>\n<h2 id=\"4-지연-로딩lazy-loading\" style=\"position:relative;\"><a href=\"#4-%EC%A7%80%EC%97%B0-%EB%A1%9C%EB%94%A9lazy-loading\" aria-label=\"4 지연 로딩lazy loading permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 지연 로딩(Lazy loading)</h2>\n<p>지연로딩을 사용해서 Team 엔티티에 대해서 ManyToOne 매핑을 한다고 하면, 아래와 같이 FetchType을 Lazy로 설정해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Id</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@ManyToOne</span><span class=\"token punctuation\">(</span>fetch <span class=\"token operator\">=</span> <span class=\"token class-name\">FetchType</span><span class=\"token punctuation\">.</span>LAZY<span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> team_id<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러면 JPA에서 member를 find했을 때 member 테이블만 select 해 온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> m <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> member<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// member 테이블만 select</span></code></pre></div>\n<p>아래를 실행하면 Team 프록시 객체를 반환함을 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"m=\"</span><span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>아래와 같이 Team 엔티티의 실제 값을 조회오고자 할 때 그 시점에 JPA에서 Team 테이블에 대한 select 쿼리를 날려서 데이터를 조회해온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">m<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 이 시점에 select 쿼리 날림 </span></code></pre></div>\n<p>정리해보면 아래와 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABa0lEQVQ4y42TW4+CMBCF+/9/kMojL75qIg8uoHEBo1y9goDi2ZxJuul2zbqTDCV05sw306JutxvKsoRtj8cD5/MZp9NJVsY9n88fMff7XXKjKMJut8PlcoHiY71eS3Ce59hsPpFlGVarFRzHgTNxMBqNsFwukaYpttst4jgWAd/3EQQBPM9DGIayr7quQ1VV6PteaOh1XWM+n2M8HstKcVIURSEUOoYg0+lUCjCfIIrtsKptbGWxWCAIQiRJImJ2y2VZwXVdzGYzod3vUyjOQc/HdNr1epUxJHGC4/Eo3/T+MAxCyn2SEUAIzYqmmE6isyi74GhYvGkaIaZI27ZSmN+5KpvKfqcxmImHw0GI6JxZ09RS0DRlz+6VMIn0geV5Ia1x9izA62XG/xJ8JU4KJrNNTUfnDbG7+VPQDGTLpPI//O8DsmPeCtrV2TIvL68RCV/FvBU0E0jGtjlDW/BfhLYo/w7OkKL6dG3BLxE/7cvtiDCAAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image4\"\n        title=\"image4\"\n        src=\"/static/1845d59f1268873ac620a122fd487dab/37523/image4.png\"\n        srcset=\"/static/1845d59f1268873ac620a122fd487dab/e9ff0/image4.png 180w,\n/static/1845d59f1268873ac620a122fd487dab/f21e7/image4.png 360w,\n/static/1845d59f1268873ac620a122fd487dab/37523/image4.png 720w,\n/static/1845d59f1268873ac620a122fd487dab/612f7/image4.png 773w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>만약에 Member와 Team을 항상 같이 조회시킨다면 지연로딩이 아닌 즉시 로딩을 사용하는 것이 낫다.</p>\n<h2 id=\"5-즉시-로딩-eager-loading\" style=\"position:relative;\"><a href=\"#5-%EC%A6%89%EC%8B%9C-%EB%A1%9C%EB%94%A9-eager-loading\" aria-label=\"5 즉시 로딩 eager loading permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 즉시 로딩 (Eager loading)</h2>\n<p>즉시 로딩을 하기 위해서는 ManyToOne의 fetchtype을 EAGER로 설정만 해주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Id</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@ManyToOne</span><span class=\"token punctuation\">(</span>fetch <span class=\"token operator\">=</span> <span class=\"token class-name\">FetchType</span><span class=\"token punctuation\">.</span>EAGER<span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> team_id<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 하면 em.find(member) 하면 Member와 Team에 대한 데이터를 조인해서 한 번에 다 가져오게 된다. 그래서 proxy객체를 사용하지 않게 된다.</p>\n<h2 id=\"6-실무에서-지연로딩만-쓰는-이유\" style=\"position:relative;\"><a href=\"#6-%EC%8B%A4%EB%AC%B4%EC%97%90%EC%84%9C-%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9%EB%A7%8C-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"6 실무에서 지연로딩만 쓰는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 실무에서 지연로딩만 쓰는 이유</h2>\n<h3 id=\"1-즉시-로딩을-사용하면-전혀-예상할-수-없는-sql이-발생한다\" style=\"position:relative;\"><a href=\"#1-%EC%A6%89%EC%8B%9C-%EB%A1%9C%EB%94%A9%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A0%84%ED%98%80-%EC%98%88%EC%83%81%ED%95%A0-%EC%88%98-%EC%97%86%EB%8A%94-sql%EC%9D%B4-%EB%B0%9C%EC%83%9D%ED%95%9C%EB%8B%A4\" aria-label=\"1 즉시 로딩을 사용하면 전혀 예상할 수 없는 sql이 발생한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 즉시 로딩을 사용하면 전혀 예상할 수 없는 SQL이 발생한다.</h3>\n<p>1,2개 조인한다고 해서 문제가 없지만, 모두 EAGER로 되어 있고 5개 테이블이 연결되어 있다고 생각하면 find시 조인이 5개~10개 테이블이 한꺼번에 불러오는 문제가 발생한다.</p>\n<h3 id=\"2-즉시-로딩은-jpql에서-n1-문제를-일으킨다\" style=\"position:relative;\"><a href=\"#2-%EC%A6%89%EC%8B%9C-%EB%A1%9C%EB%94%A9%EC%9D%80-jpql%EC%97%90%EC%84%9C-n1-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EC%9D%BC%EC%9C%BC%ED%82%A8%EB%8B%A4\" aria-label=\"2 즉시 로딩은 jpql에서 n1 문제를 일으킨다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.</h3>\n<p>N+1 문제는 쿼리를 1개 날렸는데 그에 따른 따른 쿼리를 처음 날린 쿼리의 데이터 개수인 N개 만큼 더 실행시켜야 하는 문제이다. 예컨대 EAGER로 Team을 설정 후, JPQL을 통해 member를 조회해온다고 해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Members</span><span class=\"token punctuation\">></span></span> members <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">createQuery</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select m from Member m\"</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">getResultList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그러면 select * from member 쿼리가 처음에 1번 호출되게 될 것이고,</p>\n<p>불러와놓고 보니 team이 EAGER로 설정되어 있기 때문에, member 각각에 대해서 team 데이터를 다 가지고 있어야 하기 때문에 아래와 같이 member각각에 설정된 team 데이터를 불러오기 위해 SQL문이 N번 호출되게 된다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">from</span> team <span class=\"token keyword\">where</span> team_id <span class=\"token operator\">=</span> ?</code></pre></div>\n<p>그래서 Member와 Team을 항상 같이 조회해온다고 하더라도 그냥 fetchType은 LAZY로 해두고, JPQL에서 fetch join 같은 걸 아래처럼 사용하는 것이 안전하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Members</span><span class=\"token punctuation\">></span></span> members <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">createQuery</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select m from Member m join fetch m.team\"</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">getResultList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n<p>따라서 ManyToOne, OneToOne 은 기본이 EAGER이므로 항상 LAZY로 설정해주어야 한다.</p>\n<hr>\n<h3 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h3>\n<ul>\n<li><a href=\"https://www.inflearn.com/course/ORM-JPA-Basic\">https://www.inflearn.com/course/ORM-JPA-Basic</a></li>\n</ul>","frontmatter":{"date":"March 24, 2022","title":"[JPA] 8. JPA프록시와 지연로딩(Lazy Loading)과 즉시로딩(Eager Loading)","categories":"Spring","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/jpa8/"}},"prev":{"id":"9d8e16d7-8f70-50bd-95f5-e78ca41b648f","html":"<p>운영하는 사이트에서 메일엔진 솔루션을 사용 중인데 메일엔진이 mail_queue라는 테이블에서 데이터를 긁어가서\n메일을 일괄 발송하는 방식이다.</p>\n<p>그런데 갑자기 사이트에 장애가 발생해서 mail_queue 테이블에 데이터가 insert되지 않는 에러가 발생했다.\n에러의 내용은 아래와 같았다.\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">JDBC-5074: Given String does not represent a number in proper format. </code></pre></div>\n<br>\n<p>이 문제를 구글링 해보니 tibero에서 자동 형변환을 지원하지 않아서 NUMBER인 컬럼에 string을 insert 시도하는 것이 문제라고 하는데,\n뭔가 내 경우랑 맞지 않는 것 처럼 보였다.</p>\n<p>그리고 로컬에서, 개발서버에서도 해당 에러가 재현되지 않고 디버깅을 찍어보아도 insert되는 데이터는 정상이었다.</p>\n<p>문제는 바로 INSERT를 수행하기 전 key 값을 sql로 채번하는 것이었다.\nmail_queue 테이블의 PK인 메일 id( mail_id )값을 기존의 테이블의 mid값 중 max값을 불러와 여기에 1을 더한 뒤에 insert하는 데,\nDB의 mid값에 특수기호가 들어있던 것이 문제였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token operator\">&lt;</span>selectKey resultType<span class=\"token operator\">=</span><span class=\"token string\">\"String\"</span> keyProperty<span class=\"token operator\">=</span><span class=\"token string\">\"mail_id\"</span> <span class=\"token keyword\">order</span><span class=\"token operator\">=</span><span class=\"token string\">\"BEFORE\"</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token punctuation\">[</span>CDATA<span class=\"token punctuation\">[</span>\n<span class=\"token keyword\">SELECT</span> DECODE<span class=\"token punctuation\">(</span>\n<span class=\"token function\">MAX</span><span class=\"token punctuation\">(</span>mail_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\nTO_CHAR<span class=\"token punctuation\">(</span>SYSDATE<span class=\"token punctuation\">,</span> <span class=\"token string\">'YYYYMMDD'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token string\">'00001'</span><span class=\"token punctuation\">,</span>\nTO_CHAR<span class=\"token punctuation\">(</span>TO_CHAR<span class=\"token punctuation\">(</span>SYSDATE<span class=\"token punctuation\">,</span> <span class=\"token string\">'YYYYMMDD'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> LPAD<span class=\"token punctuation\">(</span>TO_NUMBER<span class=\"token punctuation\">(</span>SUBSTR<span class=\"token punctuation\">(</span><span class=\"token function\">MAX</span><span class=\"token punctuation\">(</span>mail_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span>  mail_id\n<span class=\"token keyword\">FROM</span> mail_queue\n<span class=\"token keyword\">WHERE</span> TO_CHAR<span class=\"token punctuation\">(</span>sdate<span class=\"token punctuation\">,</span> <span class=\"token string\">'YYYYMMDD'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> TO_CHAR<span class=\"token punctuation\">(</span>SYSDATE<span class=\"token punctuation\">,</span> <span class=\"token string\">'YYYYMMDD'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>selectKey<span class=\"token operator\">></span></code></pre></div>\n<p>수동으로 DB에 메일 데이터를 생성해 넣었던 것이 문제였던 것이다.</p>\n<p>단순한 에러이지만 로컬/개발서버에서 재현되지 않았던 것이 당황스러웠는데,,</p>\n<ul>\n<li>INSERT 하기 전에 채번을 수행할 수 있다는 점,</li>\n<li>로직이 아닌 data가 문제를 발생시킬 수 있다는 점</li>\n</ul>\n<p>을 기억해야 겠다. 끝.</p>","frontmatter":{"date":"March 28, 2022","title":"[Error] insert시 select key 후 inesrt로 인한 에러 발생 조치 (JDBC-5074: Given String does not represent a number in proper format)","categories":"Error","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/error-insert/"}},"site":{"siteMetadata":{"siteUrl":"https://jjunyong.github.io","comments":{"utterances":{"repo":"jjunyong/jjunyong.github.io"}}}}},"pageContext":{"slug":"/error-json-serialize/","nextSlug":"/jpa8/","prevSlug":"/error-insert/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}