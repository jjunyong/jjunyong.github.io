{"componentChunkName":"component---src-templates-blog-template-js","path":"/network-practice3/","result":{"data":{"cur":{"id":"667f083c-01cb-58d6-99fe-4390e99377cf","html":"<h2 id=\"tcp란\" style=\"position:relative;\"><a href=\"#tcp%EB%9E%80\" aria-label=\"tcp란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP란?</h2>\n<ul>\n<li>Transmission Control Protocol</li>\n<li>L4 계층 통신</li>\n<li>TCP의 가장 중요한 키워드는 “커넥션”이다. 통신 전에 커넥션을 맺고 통신이 끝나면 커넥션을 해지한다.</li>\n<li>HTTP 통신을 할 때도 TCP/IP 통신을 기반으로 한다.</li>\n</ul>\n<h3 id=\"tcp-통신의-과정\" style=\"position:relative;\"><a href=\"#tcp-%ED%86%B5%EC%8B%A0%EC%9D%98-%EA%B3%BC%EC%A0%95\" aria-label=\"tcp 통신의 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP 통신의 과정</h3>\n<ul>\n<li>연결 : 3 way handshaking\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.222222222222214%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABzklEQVQoz2WTWXPaQBCE+f//JW9O2QWUjTEYXSsZqgLmKEBgBAadIIyRBF9KK0MS56GrR3u0pmdmS2xNvuMc5SwgFrAT/+2zM4mXz2wXT6SB4OBbcv2wViidI8Ep/Be52MfGZDUzcReCcyi4nPs7zgKD97mBN2mSuEoh6DhNlN5PrGEZa1jBGJTxVwrxUmc6UFnZGvu1TqM9oiKmVE2bzmDM0dWIVy08R+Nz0SBxVY6eTikJDPaezodnXJHbkJYjXVo+RYLYbRN7HXabDge/I7NLAx3cFmyaZIFOkgteaiKx/ard1iJzNbKNWtQzKsSPmxappxb2NqrMKlqqDEcW4Uon9TVKZ9kEUVzav0BgcBpXYVaFt3sypw6HNqf9C+G8ztZp4g7KkvfLBo6t8uO5y2yiyR9KQUIDd15nYteY2ffYU5Nf/R6vwx5R94kP847YuCWxGxBb/HFlFRyqEBcOS5cRGb+pNLs19P4DSn/IjbLgTji8qxrryg3r8i2HcXExd3TpdF63NDCua1fBLBCyGTknfs4mqS8k8vjTNWRnU18n8TVZrzw+hcbX7IpLhkKmnuVDatcKTB9I548ko6r8TkaVIp4/FjYj8e0hiCv/Bk9223zmamqZAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image1\"\n        title=\"image1\"\n        src=\"/static/771af7861277283192467078dbd36855/37523/image1.png\"\n        srcset=\"/static/771af7861277283192467078dbd36855/e9ff0/image1.png 180w,\n/static/771af7861277283192467078dbd36855/f21e7/image1.png 360w,\n/static/771af7861277283192467078dbd36855/37523/image1.png 720w,\n/static/771af7861277283192467078dbd36855/302a4/image1.png 1080w,\n/static/771af7861277283192467078dbd36855/07a9c/image1.png 1440w,\n/static/771af7861277283192467078dbd36855/64289/image1.png 2838w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<ul>\n<li>데이터가 없는 Ethernet header, IP header, TCP Header로만 이루어진 SYN 패킷을 보낸다. 이 떄 TCP Header에 SYN으로 표시되어 있다.</li>\n<li>그 이후의 SYN,ACK 와 ACK 패킷도 마찬가지이다.</li>\n</ul>\n</li>\n<li>데이터 통신\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABoklEQVQoz22S2Y7aQBBF+f8fyUuk5CVCCpkFDYTBbi8w00wUGDYH72CMbcySzIm8RJAoD0dV3VVdulXVjbdYg8SA1ITUuJAYnLcqkXdP5LU5RQpkGmQC0pqdxlusw64m1mkUztZ/xHU6BG63xHM65GuVQ9jDtVo41mdSv4tvP7FYSOwfEnclOW6MS9FC2E4rChq8Ltro31sMJzclxvgLrtXlFCocQ4XzWuUY9DFG37gz5rTNKd3hjJ0/gORKZaHwr5YLm5iVX7fxaysoc4pz+v+WL2hVyxXalRWQ6JxjlZ9x5RdKLjnXb7QqllSxxmHTJwsVDpFgv1bJQp1sbbIPdXKvxylQOAUqeSDIA408vEaQr0XpZ77KcaPQ2AYK3Zdb7oZN+uMOTWHz7sGhrS6JW028D+/ZfPrIqzFhNHAwW3bJ4NZmcL/CvFkhVZuXJ4vE1WkcIw3PVrCtHr4rsJaS+fwZZ/nMftZnO/lKNnskWgwIl5JgJgmmI8L5iGAq8ceScC4JLclpU34brZpRWs8pEdXwS6tDZtQxUd/9w58lJdWSfgMSuJIyUux5AQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image2\"\n        title=\"image2\"\n        src=\"/static/b9699a633cbe86abd39fda43c7891214/37523/image2.png\"\n        srcset=\"/static/b9699a633cbe86abd39fda43c7891214/e9ff0/image2.png 180w,\n/static/b9699a633cbe86abd39fda43c7891214/f21e7/image2.png 360w,\n/static/b9699a633cbe86abd39fda43c7891214/37523/image2.png 720w,\n/static/b9699a633cbe86abd39fda43c7891214/302a4/image2.png 1080w,\n/static/b9699a633cbe86abd39fda43c7891214/07a9c/image2.png 1440w,\n/static/b9699a633cbe86abd39fda43c7891214/e3815/image2.png 2730w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<ul>\n<li>HTTP 통신이라고 가정하면, HTTP 헤더/바디를 포함한 message 데이터가 추가된 데이터 패킷을 주고 받는다.</li>\n</ul>\n</li>\n<li>해지 : 4 way handshaking\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABLklEQVQoz32S2W6CQBRA+f8/arq8NCLKANZGbas1aiqLsgpEQfA0LBbTJn04mTvbnXtmRrpEOpdIo2m7mIMOiQZxN1e2EI+IzR7u6oky0CkDo16f2jISBwPiF4iNG/R6YWaOyG2jTS4gUX8oQ43cH3LcCpKVShEKjjsFyXcURvM7pssHZstHxot7PKdP7ggc3cCf6PVGY/ZOb/yJPF7w+jGnDHUyb0juyGTmM2df5bQfIKWeimX2cOw+O1vBtmRSV4VKPRa1clWN+TVhs3ljtZ5hbacUgcZx3+fsGiRrgyJQyb1hpVzp3OgmrWJF1HJVTlsSQRkKEkvmtFM42QpFIMjcAVLzCL9pEl3+oar6HAhKd0Bhy3W/vsOmGq2rqIoj/S+H7pAqvv6IejzurL4B9soE7KUpRVQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image3\"\n        title=\"image3\"\n        src=\"/static/8df1224374136a8db0467c79e5ee4822/37523/image3.png\"\n        srcset=\"/static/8df1224374136a8db0467c79e5ee4822/e9ff0/image3.png 180w,\n/static/8df1224374136a8db0467c79e5ee4822/f21e7/image3.png 360w,\n/static/8df1224374136a8db0467c79e5ee4822/37523/image3.png 720w,\n/static/8df1224374136a8db0467c79e5ee4822/302a4/image3.png 1080w,\n/static/8df1224374136a8db0467c79e5ee4822/07a9c/image3.png 1440w,\n/static/8df1224374136a8db0467c79e5ee4822/34e83/image3.png 2852w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<ul>\n<li>해지도 연결과 마찬가지로 데이터가 없는 FIN, ACK 패킷을 주고받음으로써 연결을 해지한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<ul>\n<li>L7의 프로토콜에 따라 다르지만 데이터 통신이 오고가는 과정에서 계속 3 way handshake를 하는 것이 아니다.</li>\n<li>데이터 패킷 1개만 보내기 위해서 통신을 한다고 하면 총 몇개의 패킷을 보내야 하는가?\n<ul>\n<li>3 + 1 + 4 = 총 8개의 패킷을 주고 받게 된다. 이는 비효율적으로 보일 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"tcp-통신-추적-실습\" style=\"position:relative;\"><a href=\"#tcp-%ED%86%B5%EC%8B%A0-%EC%B6%94%EC%A0%81-%EC%8B%A4%EC%8A%B5\" aria-label=\"tcp 통신 추적 실습 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP 통신 추적 실습</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 80 포트 기준으로 필터링하여 TCP/IP 통신과정 캡쳐하기 </span>\n<span class=\"token function\">sudo</span> tshark <span class=\"token parameter variable\">-i</span> <span class=\"token punctuation\">{</span>network interface명<span class=\"token punctuation\">}</span> <span class=\"token string\">\"tcp port 80\"</span>\n\n<span class=\"token comment\"># 다른 터미널에서 curl 실행</span>\n<span class=\"token function\">curl</span> www.google.com</code></pre></div>\n<ul>\n<li>캡쳐 결과 분석하기\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABc0lEQVQoz1WSy1KEMBBF+SYdZoAkkCc4T3V0o1Uu9P//4Vr3Bqp0kYIE+vTp7jR+XlDOF1zvb/j6+cb7xyc643AYLFrjsOsN9sahHRz2ZtQ62Gl91neuqcwYU0ZjY8H59Y58umC+3FDOV0x5gUsFg4/oRo9+ilrGJ51ty8ascxsyXCzoxoCGgVN50kcBpoCD8zAh/wveoLvBYtdbGbZmxG5wejLmsTdoxjwjH88Y0ywILZiJiSo0VdspyoJwVRCL1lQWsMrOBbWl4QHLtCnDhITeR2WjMfcEELiVRjCBTMx/KMT/DtbLugnLUf2rPUsKFHC1k5mAQcb8XqtJWgQSTCCHIyCHUUtMglCfZShIJc//DAncktm1DXtOnsD4dMJ8va0l1oDNcOvpZrhZa6LOV8g6HMbwTEM5vdxB0zrNIPV6RWoLqg1tK9CGIjMm8hpKTc59k04XLNdngXgFeCUeOlPf132rZ73ctKFZu5q1fy+9HfELOXZcNTWSGooAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image4\"\n        title=\"image4\"\n        src=\"/static/2b1f9b25fff789fef6aa2db7d380c3d5/37523/image4.png\"\n        srcset=\"/static/2b1f9b25fff789fef6aa2db7d380c3d5/e9ff0/image4.png 180w,\n/static/2b1f9b25fff789fef6aa2db7d380c3d5/f21e7/image4.png 360w,\n/static/2b1f9b25fff789fef6aa2db7d380c3d5/37523/image4.png 720w,\n/static/2b1f9b25fff789fef6aa2db7d380c3d5/302a4/image4.png 1080w,\n/static/2b1f9b25fff789fef6aa2db7d380c3d5/07a9c/image4.png 1440w,\n/static/2b1f9b25fff789fef6aa2db7d380c3d5/84bc0/image4.png 3176w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<br>\n<ul>\n<li>제일 처음에 1,2,3번행에서 3 way handshake가 이루어짐을 알 수 있다.\n<ul>\n<li>Len=0이라는 것은 data길이가 0이라는 것이다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">ACK</code>가 연결/해지에서만 쓰이는게 아니라 통신 시에 데이터를 받으면 다 ACK로 보내준다.</li>\n<li>TCP segment of a reassembled PDU 는 HTTP 통신 시에 tcp 패킷을 나눠서 송신하는데 수신 시에 segment를 재조립하여 전체 메시지 또는 데이터 스트림을 얻게 된다. 즉, <code class=\"language-text\">TCP segment of a reassembled PDU</code> 메시지는 수신된 TCP 세그먼트가 TCP PDU의 재조립된 일부임을 의미한다.</li>\n<li>마지막에 [FIN, ACK], [FIN, ACK]는 4 way handshake의 과정과 동일한 절차는 맞으나 약간 다른 방식으로 진행된 것임</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"http-통신의-특성\" style=\"position:relative;\"><a href=\"#http-%ED%86%B5%EC%8B%A0%EC%9D%98-%ED%8A%B9%EC%84%B1\" aria-label=\"http 통신의 특성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP 통신의 특성</h4>\n<ul>\n<li>연결을 맺고, 데이터를 보내고, 연결을 끊는다. 그렇기에 TCP 연결/해지를 위한 패킷을 여러번 주고받음으로써 그에 대한 네트웍 오버헤드는 있을 수 있으나, 서버 입장에서는 소켓을 클라이언트를 위해 계속 물고 있지 않아도 되기 때문에 오히려 서버 자원의 관점에서는 더 효율적이다.</li>\n</ul>\n<h4 id=\"연결해지의-clientserver-상태-들여다보기\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B2%B0%ED%95%B4%EC%A7%80%EC%9D%98-clientserver-%EC%83%81%ED%83%9C-%EB%93%A4%EC%97%AC%EB%8B%A4%EB%B3%B4%EA%B8%B0\" aria-label=\"연결해지의 clientserver 상태 들여다보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연결/해지의 Client/Server 상태 들여다보기</h4>\n<ul>\n<li><strong>3 way handshake 연결에 따른 서버 상태</strong>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACtklEQVQ4y12TbW/aWBCF/f9/xWo/bVRBNlU3EAUHYzAQbGwMfgFsYxtcKKEhaV6BAE/lm6a72pFGM9K992jmnHOll5dHDocDz8+PGLpO9jVju93w+vrCbrfl7W0r6n9zs3nlbbdlNkux7R7r9ZrDYc9ut0PS9WsamoaqqrSaLSzLYjQa4TguWZbxEcfjUdT8sWmaDIdDUZvNJopSE7XVaiFpjRrFYoHz838IwzFRFBEEgQDN+w+wfIs8lsslvu+zWCyYz+ckSYKiVDktFpHlS6S+3aVer9Lr6fT7PXRdx7JMDMMgjif8P1arFeVymXq9jlKrCXCrp6Mol9i2jpQmMb4/FAftdotqtfp+Wanij0IB8vT4xHp9J/qbmxWlUglZltE0jSAM6CgOF0WNTs1GisIQwzAFaL/fp1pVaDQa1Bt1LHvMwxM43lc6xvv6t9+Xgi/P9wTfrusydHz01jW+4yLJcoc//jznU+FKTGnbNtfttgANxmMO+z2bzRu3dy/c3u8x7QWnp0Uqsky5fCHEC6IAq28xy2ZI+aOuaeJ5PpNJJEBz/q7kK4bjkZgqGiX0Oi7HLYy9hVi5pqqCHtO0UEpNvvxVoXahIc3SBM9xSZNUgH2oG4Yh4Shm83BkmTwyj36w3+Si3AhqkjgW9+I4xu5atFSNvmkiWY7JpSbTMDS0ZkOsWiwUOPt8RlsZs3mGu/t7br6vfqt8cnIilDaMLlE0IU5iXM8lnU6Rrq4vKKqf+KwWCaIR03QqfJhTkav89JqLMqetT34BLnGcAbPZTBg/iRPSeIo38MimGVI6iZglU6ZJKsbPM01TJpOJWEsYG9hs4f4Bur1vVCoVOrpOu91mPA5QjBqn8t+ohorkugNczxMj59X7lYPBQPD477d7/ylZ9k34Lz/PHZHzWVK/ULg84Vw54yeSWpjDanz5CAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image5\"\n        title=\"image5\"\n        src=\"/static/45328a07a010ae3cb7622ca6a25fda77/37523/image5.png\"\n        srcset=\"/static/45328a07a010ae3cb7622ca6a25fda77/e9ff0/image5.png 180w,\n/static/45328a07a010ae3cb7622ca6a25fda77/f21e7/image5.png 360w,\n/static/45328a07a010ae3cb7622ca6a25fda77/37523/image5.png 720w,\n/static/45328a07a010ae3cb7622ca6a25fda77/302a4/image5.png 1080w,\n/static/45328a07a010ae3cb7622ca6a25fda77/07a9c/image5.png 1440w,\n/static/45328a07a010ae3cb7622ca6a25fda77/037ab/image5.png 2274w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<br></li>\n<li><strong>4 way handshake 해지에 따른 서버 상태</strong>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAADlklEQVQ4y02UeW/bRhDF+f2/QYMiQdw/0gKOE9eHbMmOTJEiKd6XDkqWbEuyrRRNdR+kpPwKrt00CzzOLjH79u3MzkjzxZzlaoFZM3Bsm+lkwmQyZrGYk2UpWbp5RSown02Zz2b89XWEUqnQaNSF73K5oNtuICmyws0XGdtyqNfrtFqtH9judvw80jQlCAKazabw9YMAraqjyCpqRcXUdaR3f77lzeEvWEGNdtIWzkmSiA3bLBVE2atdrlZEUcRgMOD+/p7R84iSVuLN0RvefvoVTZeR5FqZqq3geCbHx8ccHh5ycPCeG1lnPN0yHi+papEg3G1TNF3DMAw0rUqlomD7FlW7ghUaeF4NySod4pY/E7sarVaC6zjIsozreszmKZNpStJ5ZjLf0XtYc3pWpFA45/KyRLPVYvj4RKOZMBg+04hDJNcxiSMPz7U5OjqiVCxxcXGBbdvAnvVyhXplsV7sGA3WFM6vOD455rJYRDd0fMvEuL7CVRVCN1eoXuNoZXq3Cb7vU6lUqJk61bLH3/016XLPcrxlu0Fk27YtwjDEdR2hMNAUKh8/oJ8c4hoVJKP8Gf3LJzxLJYxiPM/DdV08z2e5WJFlGfP5jP33LZvNBlVRMU0TTdfxPY+H4ZA4Seg/j6jXQ6T8/o1WgmXZ1Go1QWY7Dr7vkWYp438mGGWfxTRl9m3DRaEoQnJ6ckrhskjd89BKRUJDJ/JspHqjSStJeHx8Ek/Gsixcz8ZQfL49bph9W9FpPpCt92xWqciuruvomk5UbxBrCtrRB6yzj3iGinRz9jvy+R80Q5NW0ub8PM9gAVk2GX3NeHwac3Juku32bLdbSsUi11dX4oG3220GwyFRo8H9YEAjjpAC7SOh/plet8twOOTp6YnRaETnti1ilmYwne+Yzvc020tKJYVaTUfXDXGjOI64vr6iWlXxHQup1wm4u41I2l0syxRJya8dBKFIyMv4Lr6bzZowDOh2u3Q6He7u7oiiAF1XMM0qvlND6tz26PbukW9uODg44LeD97x99w5VrbJ7reX9/oVwtVqL0nt4eBBkOfISzNf9/oA4CpA6nTbd21vxM28IcRwLm9dy3gyEvu8vhOv1C2FO0uv1fiBXLNQGLpKqKlQqMknSFEWfI49l3iDyGP5MuFqtxIH/NYdcRI583u/3qecKb8qXfLkuYJmaOD2PURgEYmOe1Z8J8wMcx3n1C4X9fx5jmzr/Alngr9yBDB/uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image6\"\n        title=\"image6\"\n        src=\"/static/589e810aecbf6048966058bb32584d0a/37523/image6.png\"\n        srcset=\"/static/589e810aecbf6048966058bb32584d0a/e9ff0/image6.png 180w,\n/static/589e810aecbf6048966058bb32584d0a/f21e7/image6.png 360w,\n/static/589e810aecbf6048966058bb32584d0a/37523/image6.png 720w,\n/static/589e810aecbf6048966058bb32584d0a/302a4/image6.png 1080w,\n/static/589e810aecbf6048966058bb32584d0a/07a9c/image6.png 1440w,\n/static/589e810aecbf6048966058bb32584d0a/e3729/image6.png 1794w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<br>\n<ul>\n<li>FIN을 받은 Client에서 왜 바로 CLOSED 상태로 되지 않고 TIME WAIT이라는 상태를 두는가? 네트웍 지연이나 패킷이 유실되어 재전송되는 예외 상황을 위해 기다리기 위함이다.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"netstat을-통한-tcpip-추적-실습\" style=\"position:relative;\"><a href=\"#netstat%EC%9D%84-%ED%86%B5%ED%95%9C-tcpip-%EC%B6%94%EC%A0%81-%EC%8B%A4%EC%8A%B5\" aria-label=\"netstat을 통한 tcpip 추적 실습 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>netstat을 통한 TCP/IP 추적 실습</h3>\n<ul>\n<li><code class=\"language-text\">netstat -antp</code> 명령으로 network 상태를 볼 수 있는데, 상태가 너무 빨리 변화하기 때문에 이를 추적하기 위해서 아래 스크립트를 사용해본다.\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># netstat-log.sh 생성</span>\n\n<span class=\"token comment\">#!/bin/bash</span>\n<span class=\"token keyword\">while</span> <span class=\"token boolean\">true</span>\n<span class=\"token keyword\">do</span>\n  <span class=\"token function\">netstat</span> <span class=\"token parameter variable\">-antp</span> <span class=\"token operator\">|</span> <span class=\"token function\">tee</span> <span class=\"token parameter variable\">-a</span> test.log\n  <span class=\"token function\">sleep</span> <span class=\"token number\">0.1</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token comment\"># netstat-log.sh 실행하기</span>\n./netstat-log.sh \n\n<span class=\"token comment\"># 다른 터미널에서 curl로 테스트하기</span>\n<span class=\"token function\">curl</span> www.google.com\n\n<span class=\"token comment\"># netstat 로그 결과에서 TCP 연결상태값 변화과정 확인하기</span>\n<span class=\"token function\">vi</span> test.log</code></pre></div>\n</li>\n</ul>","excerpt":"TCP란? Transmission Control Protocol L4 계층 통신 TCP의 가장 중요한 키워드는 “커넥션”이다. 통신 전에 커넥션을 맺고 통신이 끝나면 커넥션을 해지한다. HTTP 통신을 할 때도 TCP/IP 통신을 기반으로 한다. TCP 통신의 과정 연결 : 3 way handshaking\n 데이터가 없는 Ethernet header, IP header, TCP Header로만 이루어진 SYN 패킷을 보낸다. 이 떄 TCP Header에 SYN으로 표시되어 있다. 그 이후의 SYN,ACK 와 ACK 패킷도 마찬가지이다. 데이터 통신\n HTTP 통신이라고 가정하면, HTTP 헤더/바디를 포함한 message 데이터가 추가된 데이터 패킷을 주고 받는다. 해지 : 4 way handshaking\n 해지도 연결과 마찬가지로 데이터가 없는 FIN, ACK 패킷을 주고받음으로써 연결을 해지한다. L7의 프로토콜에 따라 다르지만 데이터 통신이 오고가는 과정에서 계속 3 way …","frontmatter":{"date":"January 23, 2024","title":"TCP/IP 통신과정 추적","categories":"Linux","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/network-practice3/"}},"next":{"id":"61b0e906-b9a8-5a86-baeb-f9f04aa69b87","html":"<h2 id=\"네트워크-통신과정--라우팅-추적\" style=\"position:relative;\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95--%EB%9D%BC%EC%9A%B0%ED%8C%85-%EC%B6%94%EC%A0%81\" aria-label=\"네트워크 통신과정  라우팅 추적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>네트워크 통신과정 : 라우팅 추적</h2>\n<h3 id=\"traceroute\" style=\"position:relative;\"><a href=\"#traceroute\" aria-label=\"traceroute permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>traceroute</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">traceroute</span> <span class=\"token parameter variable\">-n</span> www.google.com</code></pre></div>\n<ul>\n<li>중간에 보이는 * 은 보안, 설정, 부하 등으로 인해 응답이 없었던 라우터이다.</li>\n<li>처음에 LAN의 gateway를 타고 나가서 router들을 거쳐 목적 서버로 도착하게 된다.</li>\n<li>동일 hop에 여러개의 ip가 나타나는 것은 여러 개의 경로가 있을 수 있음을 의미한다.</li>\n</ul>\n<h3 id=\"icmp란\" style=\"position:relative;\"><a href=\"#icmp%EB%9E%80\" aria-label=\"icmp란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ICMP란?</h3>\n<ul>\n<li>Internet Control Message Protocol</li>\n<li>L3 통신이다. (TCP통신이 아님에 유의)</li>\n<li>라우터를 포함한 네트웍 장치가 통신 체크 용도로 사용된다.</li>\n</ul>\n<h3 id=\"ping\" style=\"position:relative;\"><a href=\"#ping\" aria-label=\"ping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ping</h3>\n<ul>\n<li>tshark 설치하기\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> tshark <span class=\"token parameter variable\">-i</span> <span class=\"token punctuation\">{</span>network if명<span class=\"token punctuation\">}</span> <span class=\"token parameter variable\">-f</span> icmp <span class=\"token parameter variable\">-Y</span> <span class=\"token string\">\"ip.dst == 8.8.8.8\"</span></code></pre></div>\n</li>\n<li>-f, -Y옵션은 패킷 filtering을 위해 사용되며 -f는 protocol을 필터링하고, -Y 뒤에는 표현식을 적어주어 필터링한다.</li>\n</ul>\n<hr>\n<h2 id=\"arp란\" style=\"position:relative;\"><a href=\"#arp%EB%9E%80\" aria-label=\"arp란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ARP란?</h2>\n<ul>\n<li>Address Resolution Protocol</li>\n<li>L2(데이터링크 계층) 통신</li>\n<li>IP주소를 MAC주소에 매핑하기 위하여 사용된다.</li>\n<li>최종 목적지의 MAC주소를 이더넷 프레임에 포함하지는 않는다. (목적지가 LAN내라면 그럴 수 있다.) 외부로의 통신이라면 gateway의 MAC주소를 목적지지로 이더넷 프레임에 포함시켜야 한다. 어쨌든, 두 경우 모두 MAC주소를 패킷에 포함시켜야 함은 맞기 때문에 MAC주소를 얻어 와야하며 이를 위해 ARP 프로토콜이 사용된다</li>\n</ul>\n<br>\n<blockquote>\n<p>다른 네트웍 망으로 통신의 경우 라우터는 목적지 Gateway의 MAC 주소를 사용하여 이더넷 프레임을 만들어 해당 네트워크로 패킷을 전송한다. 이런 과정을 통해 패킷은 목적지 네트워크로 계속해서 전달되고, 각 네트워크마다 라우터가 목적지 Gateway의 MAC 주소 데이터를 담은 이더넷 프레임을 만들어 전송된다.</p>\n</blockquote>\n<h3 id=\"arp-추적과정\" style=\"position:relative;\"><a href=\"#arp-%EC%B6%94%EC%A0%81%EA%B3%BC%EC%A0%95\" aria-label=\"arp 추적과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ARP 추적과정</h3>\n<ul>\n<li>각 네트워크 장치(컴퓨터)는 ARP 테이블을 지니고 있다.</li>\n<li>Linux에서는 <code class=\"language-text\">ip neigh</code>명령으로 확인 가능하며 동적으로 ip를 할당하고 디바이스들이 자주 변경되는 LAN환경에서는 ARP테이블이 stale할 가능성도 있다. ip neigh명령을 해보면 <code class=\"language-text\">REACHABLE</code>과 <code class=\"language-text\">STALE</code>로 상태를 확인할 수 있다.\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ip</span> neigh\n<span class=\"token number\">172.18</span>.2.3 dev eth0 lladdr 00:1f:5e:43:24:82 REACHABLE\n<span class=\"token number\">172.18</span>.24.39 dev eth0 lladdr 04:13:56:41:27:8E STALE</code></pre></div>\n</li>\n<li>그렇다면 ARP 테이블은 어떤 방식으로 구성되는가?</li>\n</ul>\n<h3 id=\"arp-패킷-보내는-과정-추적하기\" style=\"position:relative;\"><a href=\"#arp-%ED%8C%A8%ED%82%B7-%EB%B3%B4%EB%82%B4%EB%8A%94-%EA%B3%BC%EC%A0%95-%EC%B6%94%EC%A0%81%ED%95%98%EA%B8%B0\" aria-label=\"arp 패킷 보내는 과정 추적하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ARP 패킷 보내는 과정 추적하기</h3>\n<ul>\n<li>tshark 대신 tcpdump를 사용할 수도 있다. tcpdump는 tcp 패킷만 볼 수 있는 것이 아니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># ARP 패킷 추적</span>\n<span class=\"token function\">sudo</span> tcmdump <span class=\"token parameter variable\">-xxi</span> <span class=\"token punctuation\">{</span>network interface<span class=\"token punctuation\">}</span> arp  <span class=\"token comment\">#1</span>\n<span class=\"token function\">sudo</span> tcmdump <span class=\"token parameter variable\">-xxi</span> <span class=\"token punctuation\">{</span>network interface<span class=\"token punctuation\">}</span> arp and src <span class=\"token punctuation\">{</span>내 컴퓨터 ip<span class=\"token punctuation\">}</span> <span class=\"token comment\">#2 내 PC가 보낸 ARP 패킷들에 대해서만 필터링해서 볼 수 있다. </span>\n<span class=\"token function\">sudo</span> tcmdump <span class=\"token parameter variable\">-xxi</span> <span class=\"token punctuation\">{</span>network interface<span class=\"token punctuation\">}</span> arp and dst <span class=\"token punctuation\">{</span>LAN 대역의 목적지 ip<span class=\"token punctuation\">}</span> <span class=\"token comment\">#3</span>\n\n<span class=\"token comment\"># LAN의 대역의 ip에 대해 ping을 하게 되면 ICMP 패킷을 보내기에 앞서, ARP 패킷을 보내서 MAC주소를 먼저 알아내게 된다. </span>\n<span class=\"token function\">ping</span> <span class=\"token punctuation\">{</span>LAN 대역의 목적지 ip<span class=\"token punctuation\">}</span></code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAACB0lEQVQoz1WRS2sTYRSG8xOqmUlsjTGtIZfJpZ1Jmsw3k0lTmyktRf0NSgWbVBCh0NiL9RbE4kIF19KCCEK97ETrqsUi6CLpSoorK6YRaZG6cPNoJ0Fw8fDwvYfvnAPH1dz+yO7OJr+adfabdfYadX426+x+q7HXqLH/fRMa7+DrOuxswJc12FptvbfXWm5sOP796Q2urQ8vuV+9zPWFiyxUJpmvTHK1UmZ2uszcdJlrM2VuzJS4NVumOlememWC6tR5qrMlqvOTDjdnSty7PcWPz29xvXr6APVEJ10BDx5Jwus5QKbTK+OV3XgkN0e8HifzyDKyLDlIkhvJfRhZcnOoo4OegJ/6+hNcLx7fJa6m0Pp1BnICPaOh92vkLRNDZDBFBpFRyRlZpxZTQsSVEAklTDIWIRmPEIuGSPUpvF9dwrWydIecyGDbJxkazHN6xMYuWA6jQwXGhoew8wJ7wMAyMs4QyxRYpk7BSFPMC+d/bzzCxutHuJ4tLxIL93Dm1CgjxUEuGBrjhsqEmeKSSFAqZDkr0pwz04wOCuyc5myVjEedLdWkQjgYoC/RbriyvEjA78MUWVJqL/1KN3oiiHHgZBhLT6Ml44R6AijhIJHgcQL+o218dPt9HPN1EYsGWw1Xnz+kWNAxs33kdBVT1xyMts2DLKv+Z0to/8gbKScfG85T+3uUP0UQSLtJymgDAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image1\"\n        title=\"image1\"\n        src=\"/static/5ccf10c75cb879e4258ac18da4d2a7a6/37523/image1.png\"\n        srcset=\"/static/5ccf10c75cb879e4258ac18da4d2a7a6/e9ff0/image1.png 180w,\n/static/5ccf10c75cb879e4258ac18da4d2a7a6/f21e7/image1.png 360w,\n/static/5ccf10c75cb879e4258ac18da4d2a7a6/37523/image1.png 720w,\n/static/5ccf10c75cb879e4258ac18da4d2a7a6/302a4/image1.png 1080w,\n/static/5ccf10c75cb879e4258ac18da4d2a7a6/07a9c/image1.png 1440w,\n/static/5ccf10c75cb879e4258ac18da4d2a7a6/b9bfc/image1.png 3112w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>위의 3번 명령을 실행시킨 상태에서 다른 터미널에서 ping명령을 하게 되면 위와 같은 결과가 나오는 것을 볼 수 있는데, 이 때 ARP 패킷은 브로드캐스팅되며, 송신지 MAC의 주소가 내 PC MAC주소로 되어있음을 확인할 수 있다.</li>\n<li>ARP 요청을 받은 호스트는 자신의 MAC 주소를 ARP 응답 패킷에 담아 송신 호스트에게 직접 응답한다. 해당 응답 패킷에는 목표 IP 주소와 해당 IP 주소에 대한 MAC 주소가 포함됨.</li>\n</ul>\n<h3 id=\"arp-테이블-지우기\" style=\"position:relative;\"><a href=\"#arp-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%A7%80%EC%9A%B0%EA%B8%B0\" aria-label=\"arp 테이블 지우기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ARP 테이블 지우기</h3>\n<ul>\n<li>전체 테이블 비우기\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">ip</span> neigh flush all</code></pre></div>\n</li>\n<li>1개 지우기\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> arp <span class=\"token parameter variable\">-d</span> <span class=\"token punctuation\">{</span>ip<span class=\"token punctuation\">}</span> <span class=\"token comment\"># ARP 테이블에서 1개 ip에 대한 정보 지우기</span>\n\n<span class=\"token function\">sudo</span> arp <span class=\"token comment\"># ARP 테이블 조회( ip neigh 와 유사 ) </span></code></pre></div>\n</li>\n</ul>\n<hr>\n<h2 id=\"dns\" style=\"position:relative;\"><a href=\"#dns\" aria-label=\"dns permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DNS</h2>\n<h3 id=\"dns-동작과정-추적하기\" style=\"position:relative;\"><a href=\"#dns-%EB%8F%99%EC%9E%91%EA%B3%BC%EC%A0%95-%EC%B6%94%EC%A0%81%ED%95%98%EA%B8%B0\" aria-label=\"dns 동작과정 추적하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DNS 동작과정 추적하기</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># DNS 캐시 정보 비우기</span>\n<span class=\"token function\">sudo</span> systemd-resolve --flush-caches\n\n<span class=\"token comment\"># DNS 동작 과정 추적</span>\n<span class=\"token function\">sudo</span> tshark <span class=\"token parameter variable\">-i</span> <span class=\"token punctuation\">{</span>network interface<span class=\"token punctuation\">}</span> <span class=\"token parameter variable\">-Y</span> dns\n\n<span class=\"token comment\"># 다른 터미널에서 ping 실행해보기</span>\n<span class=\"token function\">ping</span> www.google.com</code></pre></div>\n<ul>\n<li><code class=\"language-text\">ping 8.8.8.8</code>은 되고 <code class=\"language-text\">ping google.com</code>은 안된다면 네트웍이 안되는 게 아니라 DNS 서버 정보에 대한 셋팅이 잘 안된 것이다.</li>\n<li>한 번도 통신하지 않은 상태에서 <code class=\"language-text\">ping www.google.com</code>을 실행하면 어떤 일이 일어나는가?\n<ul>\n<li>등록된 DNS 서버에 DNS 쿼리를 보내야 하는데 ARP 테이블에는 외부 네트웍망에 있는 DNS 서버 ip 에 대한 MAC주소가 없는 상태이다.</li>\n<li>따라서 ARP 브로드캐스팅을 통해 Gateway의 MAC주소를 얻어내고, 이를 이용해 패킷을 만들어 DNS 서버에 쿼리를 날린다.</li>\n<li>DNS 쿼리를 통해 알아낸 목적지의 ip 주소와 최초 ARP통신을 통해 알아낸 gateway의 MAC주소로 ICMP 패킷을 전송하게 된다.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"January 21, 2024","title":"라우팅 추적(ICMP)과 ARP","categories":"Linux","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/network-practice2/"}},"prev":{"id":"4671719b-df0c-5bf2-a894-d46d7933e872","html":"<h2 id=\"네트워크-io-과정\" style=\"position:relative;\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-io-%EA%B3%BC%EC%A0%95\" aria-label=\"네트워크 io 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>네트워크 I/O 과정</h2>\n<ul>\n<li>ESTABLISHED 그 이후.. Client와 Server는 서로 데이터 패킷을 주고 받게 된다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB40lEQVQoz02S3U/acBSG+4fvxmSXu1lMzEycmduyLzPd1Djwi4hQUmkpFGYVi+NDQBAo/bVQPmyfpc227OIk78Vz3rznzZECRyMQGtgquVyVlU2LlQ2Tzd1fiPsyoVsgZhyN0C0ybyQZKG/wqvvIVx/4ml7le26NducEvBJSBD45BZjp1FoV1pM/eXWoc2zUwM4SjBQCUSAYa4TTEp68g/XyOfbRe5TrT+ycr7KfW6PTOQW3iMTUIBxkmBpvYaKDe4nTOKFvHdOT15k3E4ReiaexBp5G1zSQD/I0SmWiXTwDFjcwibSO5LQz2I0zqtl3NK4SiK5M7y7FQy2F11fALcQgXhE8FfPO4kDtYdSahELD78uIykdE+4LISxLdXGzi9hREJ8NieAmzCsFDCre0Rd06w1S/Ua8cEjoq7XsZxTii2ZLB1VkOFTzzS2w4vs8gTUtbTJtHLMcay1Ee70GONU6eqfWD1v5rHs0kopsl8Mos+wnGNxvMO3ssbZXFKA+T8p8Likh+8xhT2aaq73FnHMRJopRzUaCd/kz1xTP81gX4BhNzG6d+yrCVxX9UeBqr/z7g70hR4bNhntlAYT68ZGnn486iPgaNc3xRIHT1GPZvd3m8TdC1zrBb6dg0FP+9ldD4DRImOuVRpm7DAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image1\"\n        title=\"image1\"\n        src=\"/static/c1e388c24b1ec74aac68ea9641a9efae/37523/image1.png\"\n        srcset=\"/static/c1e388c24b1ec74aac68ea9641a9efae/e9ff0/image1.png 180w,\n/static/c1e388c24b1ec74aac68ea9641a9efae/f21e7/image1.png 360w,\n/static/c1e388c24b1ec74aac68ea9641a9efae/37523/image1.png 720w,\n/static/c1e388c24b1ec74aac68ea9641a9efae/302a4/image1.png 1080w,\n/static/c1e388c24b1ec74aac68ea9641a9efae/07a9c/image1.png 1440w,\n/static/c1e388c24b1ec74aac68ea9641a9efae/365b1/image1.png 3184w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>송신 측에서 socker 버퍼에 패킷을 집어넣는다.</li>\n<li>패킷이 목적지에 도착하면 목적지인 수신 측 컴퓨터는 하드웨어 디바이스들이 직접 접근할 수 있는 메모리의 <strong>DMA 영역에 패킷을 저장한 이후에, CPU에 irq(interrupt 요청)를 보내서</strong> 패킷이 도착함을 알린다.</li>\n<li>hard irq, soft irq 과정 ( hi, si )\n<ul>\n<li>hard irq에서는 간단한 작업만을 하게 된다. interrupt를 통해 CPU를 깨우고, ISR이 해당 인터럽트에 대한 처리를 하게 함과 동시에 network stack에 event를 발생시켜 수신된 패킷이 있음을 알린다. (+flag set 정도)</li>\n<li>soft irq는 네트웍 스택에 의해 스케줄링 되며 스케줄에 따라 CPU가 soft interrupt handler를 실행시켜 수신된 패킷을 처리한다.\n<ul>\n<li>수신한 패킷 파싱, 헤더 분석, 검증(MAC, IP, PORT)이 이 때 일어난다.</li>\n</ul>\n</li>\n<li>위와 같이 실제 패킷 헤더를 까서 검증하는 등의 대부분의 절차는 si에서 일어난다. 따라서 top 명령에서도 hi보다는 si가 높다. 디도스 공격이 왔다라고 하면 si가 높아질 것이다.</li>\n</ul>\n</li>\n<li>soft interrupt handler에서 패킷 분석이 끝난 후에 이를 Socket 레이어에 전달하여 서버를 wake up 해주고 데이터를 가져가게 한다.</li>\n</ul>\n<br>\n<p>3,4 way handshaking과 같은 패킷을 주고 받을 때도 위의 시나리오와 동일하지만, 6번과정만 없다고 보면 된다.</p>\n<h3 id=\"패킷-구조와-tcp-control-flag\" style=\"position:relative;\"><a href=\"#%ED%8C%A8%ED%82%B7-%EA%B5%AC%EC%A1%B0%EC%99%80-tcp-control-flag\" aria-label=\"패킷 구조와 tcp control flag permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>패킷 구조와 TCP control flag</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABuElEQVQoz12Qa3OaQBSG+f+/pN+a1EzTmXgJVgMILIoXKo2JooY0ikAwF69Ph42NYz88s7vn7HnnfY+yTW3WickqbrBJLDaJYBUL3hdC3reJzS5qsJ3r7BamfG9im/VMsJ4LNjmRYLOwZU/xhjqaV0Hrl2jdG5h+yA8r5KLxgNpbEAqH6OqC6PIbcbXIyPXxmlNapQC3MsatBrjlMT3tAb8zRmn36xhuFatbw/F1dC+gYt5SFXf8bIdMRZNRrchErxJq1wSuT787xTE7CKODpbsIo0vXGdBvBygyQh41tg6RbRk1j/U6N3mbm7zPTV5nDd5mBm+zhry//DFYRebHXGyxXlhyRtk/C06xDwjSQCUdXpONVLKxSjKpsRhXycI6z2GdbWJBdjqr7FKbI+KAzT5zWA5KZL3vRM45M3FO6JeIgrp0nJP/zYWOcyJ3aLPLi/I8kNqQOYz7RR7vVTpWAXHzlV92gWRyQzrVpPDy0fgQTR12B5R97kYWj/wTDLwrwt9lOsYZevkLLe2MpztVust3+fJksE3+EzxxduJQMBuqpNM6A/cSzyoQ3pZh2ZQx8/7n/j4jO/wFwqKK68JR7EQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image2\"\n        title=\"image2\"\n        src=\"/static/43356176b16deff2b3b78de9e5d40fca/37523/image2.png\"\n        srcset=\"/static/43356176b16deff2b3b78de9e5d40fca/e9ff0/image2.png 180w,\n/static/43356176b16deff2b3b78de9e5d40fca/f21e7/image2.png 360w,\n/static/43356176b16deff2b3b78de9e5d40fca/37523/image2.png 720w,\n/static/43356176b16deff2b3b78de9e5d40fca/302a4/image2.png 1080w,\n/static/43356176b16deff2b3b78de9e5d40fca/07a9c/image2.png 1440w,\n/static/43356176b16deff2b3b78de9e5d40fca/84bc0/image2.png 3176w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>PSH 플래그는 어떤 경우인가? socket마다 send 버퍼, receive버퍼가 있어서 커널 레벨에서 버퍼가 채워질 때까지 기다릴 수 있다. PSH 플래그를 set하면 버퍼에서 대기하지 않고 바로 어플리케이션 서버로 wake up 요청이 들어가게 된다.</li>\n</ul>\n<h3 id=\"socket-통신-내부-구조\" style=\"position:relative;\"><a href=\"#socket-%ED%86%B5%EC%8B%A0-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0\" aria-label=\"socket 통신 내부 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Socket 통신 내부 구조</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABjklEQVQoz1WRa2/aMBiF+f8/aB8mVdogJZRgOxRWILAEmoSWW+5ZKSQ8VS4T24dHsi2/x8fndI6vivNRQibI3wXj3gBTH5PsFKSCMr5zSyRlLLklglv6D8n9TufjpLhGklsqKSKDeKmRuwPKxGiGW6p1GTVDRSC5HFTDXtX7v491Ln6Pz51OvtXJfZ3LYcj5/YnM08l2feJdj+z4SJkIyExIJeetIrZMooUino/52Kraae2wPA0pAoPY6hHNupSuQemOKDyD83FI4Hd5sx+IfI3Q6/IZDCGTXGMDctmQVg5V47D66jUSrDcDbHfE2hc4nuDVMygiQREKkm2f9fQ78+E3DiuN7G3AJTDqiIqwYsg1GNSZd6pAK0HT0lCOwctWMfEVC19wCUeQqlo43PRJbUm8Uuztn+wdjeWzzkz1GT9paA8/WE1HrWAomT/PmIgVyxcXa+phz2yu4b1ZsqqEx7oscrM++wzMmvOpYsyfg2oEi0jy+9cEa7JgYzk4Cwd3tfxPsGm5pW2epCUVLZIvzgxJGfG8zcYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image4\"\n        title=\"image4\"\n        src=\"/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/37523/image4.png\"\n        srcset=\"/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/e9ff0/image4.png 180w,\n/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/f21e7/image4.png 360w,\n/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/37523/image4.png 720w,\n/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/302a4/image4.png 1080w,\n/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/07a9c/image4.png 1440w,\n/static/cfd5ac0fad4ea6cf70d46e84983ab4b4/9d362/image4.png 3278w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>socket() systemcall은 file을 open하는 것과 마찬가지로 file descriptor를 반환한다. 그리고 process마다 가지고 있는 fd table에 이를 추가가 되는 형태이다.</p>\n<blockquote>\n<p>프로세스가 파일을 열면, OS는 새로운 fd를 할당해주고, 파일을 닫을 때는 해당 파일 디스크립터를 해제한다. fd table 통해 각 fd에 연결된 파일 or 소켓 등의 정보를 추적하여 프로세스가 I/O 리소스에 접근할 수 있다.\n왜 socket()은 file descriptor를 반환하는가? 리눅스에서는 네트웍 자원을 포함하여 모든 리소스를 사용할 때 VFS를 통해서 하기 떄문이다.</p>\n</blockquote>\n</li>\n<li>\n<p>open() syscall이든 socket() syscall이든 fd table에 VFS의 주요 자료구조인 <code class=\"language-text\">struct file</code>이라는 구조체를 만들어주는 것은 매한가지이며 fd는 이 구조체를 가리키는 참조이다. 파일이라면 struct file이 struct inode와 연결될 것이고 socket이라면 struct socket이 연결될 것이라는 차이점이 있다.</p>\n<blockquote>\n<p>하나의 프로세스가 여러개의 socket을 유지할 수 있다.</p>\n<ul>\n<li>process 당 fd table은 1개이지만 process가 열 수 있는 file의 개수는 여러 개임과 같은 맥락이다.(fd도 여러개)</li>\n<li>process가 open할 수 있는 파일의 개수를 확인하려면 아래 명령을 실행해보면 기본적으로는 1024임을 알 수 있다.</li>\n<li><code class=\"language-text\">ulimit -a | grep \"open file\"</code>\n<ul>\n<li>관련 에러: <code class=\"language-text\">\"Too many open file\"</code> -> 파일이라는 단어를 보더라도 클라이언트와의 소켓 커넥션과 연관지어 생각할 수 있어야 한다.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABjklEQVQoz2WSTW/aQBCG/f9/QNVDD604VFEvVVRECSmqZDvFxl+kCYQCaRwRLAwEr9cKpth+KmOSoPbwaFa7s+/szjvKyv9OLj3S+3NW+jv+zDUK6VHENkXs7MmPKIRdxaPzcp2LKirIKnEbqMjBKTyaZMJmt+6yW1vkkQXC3rMXEzZZVJGL/1HETGO7NFjMVK5GTYbjJpulQXYQSxYmvq9z7+tsHi14ciB1K5LDCxO3QrqVYFl9ctvis/qBtvOJdN2FxIPYYREYODcqlyOdeGEy9kz0cx3tTOOu36WITNKpyvZBZRf+QKFUjh2QLmwuyVZdwkmbONCqr60typyyNUibn5ZJs37B11OdUd8lHbYY195w+/EtQb2G8m8PSpFoquJfNyiE87ovSkGLi6sx75tDau3f9EYTEAbb0CRbmuzmHZQXhw6X9yYJGxnolcMvxSoXRdjjwff4Negw8zvEgzPmrRPkzTd48lCex6C8VBzFsgWvQs+jYUNiU0QG0/4X7q7rhL0Gi9YJwm1QSIe/CjxFIiRi8iUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image3\"\n        title=\"image3\"\n        src=\"/static/1497f55a8ef034196ea8ca5f51071256/37523/image3.png\"\n        srcset=\"/static/1497f55a8ef034196ea8ca5f51071256/e9ff0/image3.png 180w,\n/static/1497f55a8ef034196ea8ca5f51071256/f21e7/image3.png 360w,\n/static/1497f55a8ef034196ea8ca5f51071256/37523/image3.png 720w,\n/static/1497f55a8ef034196ea8ca5f51071256/302a4/image3.png 1080w,\n/static/1497f55a8ef034196ea8ca5f51071256/07a9c/image3.png 1440w,\n/static/1497f55a8ef034196ea8ca5f51071256/3bb53/image3.png 3286w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>struct socket도 자세히 들여다보면 struct sock으로 구성되어 있고, 이것이 우리가 말하는 “socket”의 실체이다. struct sock은 receive/read queue를 가지고 있고 해당 큐에서 패킷을 보관한다.\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;net/sock.h></span></span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 다양한 소켓 관련 필드들...</span>\n\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff_head</span> sk_receive_queue<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 수신 큐 (Read Queue)</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff_head</span> sk_write_queue<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 전송 큐 (Write Queue)</span>\n\n    <span class=\"token comment\">// 다양한 소켓 관련 필드들...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>리눅스 커널에서 패킷은 sk_buff라는 구조체에 저장하며 아래와 같이 구성되어 있다.\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 패킷의 데이터를 저장하는 버퍼</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>data<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 버퍼의 길이</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 네트워크 계층의 정보, 전송 계층의 정보, 애플리케이션 계층의 정보 등을 포함하는 다양한 필드들...</span>\n    \n    <span class=\"token comment\">// 다음 패킷을 가리키는 포인터 (리스트 구조체로 구성된 큐에서 사용됨)</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff</span> <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>","frontmatter":{"date":"January 25, 2024","title":"리눅스 네트워크 I/O 분석","categories":"Linux","author":"jjunyong","emoji":"🧢"},"fields":{"slug":"/network-practice4/"}},"site":{"siteMetadata":{"siteUrl":"https://jjunyong.github.io","comments":{"utterances":{"repo":"jjunyong/jjunyong.github.io"}}}}},"pageContext":{"slug":"/network-practice3/","nextSlug":"/network-practice2/","prevSlug":"/network-practice4/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}